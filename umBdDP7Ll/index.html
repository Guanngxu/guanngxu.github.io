<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    C | Guanngxu
</title>
<link rel="shortcut icon" href="https://www.guanngxu.com/favicon.ico?v=1769266443907">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://www.guanngxu.com/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://www.guanngxu.com/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7393078395398753" crossorigin="anonymous"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://www.guanngxu.com">
                <img class="avatar" src="https://www.guanngxu.com/images/avatar.png?v=1769266443907" alt="">
            </a>
            <a href="https://www.guanngxu.com">
                <div class="site-title">
                    <h1>
                        Guanngxu
                    </h1>
                </div>
            </a>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                        <li>
                            <a href="/about" class="menu" target="_blank">
                                关于
                            </a>
                        </li>
                        
                                
                    
                            <li>
                                <a href="https://guanngxu.com/uAv93EeJY" class="menu">
                                    工具
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
    <div class="i-card">
        <b>标签：#
        C</b>
    </div>
    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/7pUUwIeSw/">
                        Linux 创建实时进程
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2023-11-28</time>
                    
                        <a href="https://www.guanngxu.com/vnEfA3xxL/" class="post-tag i-tag
                            i-tag-success">
            #嵌入式
        </a>
                        
                        <a href="https://www.guanngxu.com/umBdDP7Ll/" class="post-tag i-tag
                            i-tag-error">
            #C
        </a>
                        
                        <a href="https://www.guanngxu.com/mZ_iBKmVWo/" class="post-tag i-tag
                            i-tag-">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/7pUUwIeSw/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/7pUUwIeSw.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
深入理解LINUX内核(第三版)
linux 创建实时进程
深入 Linux 的进程优先级
Linux进程优先级系统——设置实时进程优先级

Linux 系统的调度基于分时技术，

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/7pUUwIeSw/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/8sxCrqU9f/">
                        二叉树的前序、中序、后序、层序遍历
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2023-08-19</time>
                    
                        <a href="https://www.guanngxu.com/umBdDP7Ll/" class="post-tag i-tag
                            i-tag-primary">
            #C
        </a>
                        
                        <a href="https://www.guanngxu.com/krqSF7tYC/" class="post-tag i-tag
                            i-tag-other_1">
            #算法
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/8sxCrqU9f/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/8sxCrqU9f.png) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
五分钟让你彻底理解二叉树的非递归遍历
Python实现二叉树的非递归遍历
二叉树遍历——深度优先（前中后序）+广度优先（层序遍历）

构造二叉树
定义二叉树结构如下
struct node
{
    int data;
    node *left;
    node *right;
};

构造如下形态二叉树

node *init_tree()
{
    node *node1 = (node *)malloc(sizeof(node));
    node *node2 = (node *)malloc(sizeof(node));
    node *node3 = (node *)malloc(sizeof(node));
    node *node4 = (node *)malloc(sizeof(node));
    node *node5 = (node *)malloc(sizeof(node));
    node *node6 = (node *)malloc(sizeof(node));
    node *node7 = (node *)malloc(sizeof(node));
    node *node8 = (node *)malloc(sizeof(node));
    
    node1-&amp;gt;data = 1;
    node2-&amp;gt;data = 2;
    node3-&amp;gt;data = 3;
    node4-&amp;gt;data = 4;
    node5-&amp;gt;data = 5;
    node6-&amp;gt;data = 6;
    node7-&amp;gt;data = 7;
    node8-&amp;gt;data = 8;

    node1-&amp;gt;left = node2;
    node1-&amp;gt;right = node3;
    
    node2-&amp;gt;left = node4;
    node2-&amp;gt;right = node5;
    
    node3-&amp;gt;right = node6;
    
    node5-&amp;gt;left = node7;
    node5-&amp;gt;right= node8;

    return node1;
}

前序遍历（递归）
前序遍历顺序为根左右。要遍历整个二叉树我们就需要遍历二叉树的每一个子树，对于任何一个子树它的遍历方式均为根左右顺序遍历。即所有子问题均与父问题除规模大小不同外，其余均相同。所以可以采用递归方式实现前序遍历。
// 前序遍历 根左右
void pre_order_traversal(node *root)
{
    if(root) {
        cout&amp;lt;&amp;lt;root-&amp;gt;data&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        pre_order_traversal(root-&amp;gt;left);
        pre_order_traversal(root-&amp;gt;right);
    }
}

遍历结果为：1 2 4 5 7 8 3 6
中序遍历（递归）
中序遍历顺序为左根右。其与前序遍历仅顺序不同，其余均相同。
// 中序遍历 左根右
void in_order_traversal(node *root)
{
    if(root) {
        in_order_traversal(root-&amp;gt;left);
        cout&amp;lt;&amp;lt;root-&amp;gt;data&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        in_order_traversal(root-&amp;gt;right);
    }
}

遍历结果为：4 2 7 5 8 1 3 6
后序遍历（递归）
后序遍历顺序为左右根。其与前序、中序遍历仅顺序不同，其余均相同。
// 后序遍历 左右根
void post_order_traversal(node *root)
{
    if(root) {
        post_order_traversal(root-&amp;gt;left);
        post_order_traversal(root-&amp;gt;right);
        cout&amp;lt;&amp;lt;root-&amp;gt;data&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    }
}

遍历结果为：4 7 8 5 2 6 3 1
前序遍历方法一（非递归）
因为递归实际上是由系统帮我们进行压栈，所以理论上所有递归算法都可以改为循环+栈实现，那么我们先照着上述前序遍历的样子修改为循环+栈的形态。需要注意的是由于栈先进后出的特性，为了保证左孩子在右孩子前被访问，所以应该先右孩子入栈，再左孩子入栈。
// 前序遍历 根左右
void pre_order_traversal(node *root)
{
    stack&amp;lt;node *&amp;gt; s;
    s.push(root);

    while(!s.empty()) {

        node *cur = s.top();
        s.pop();

        if(cur) {
            cout&amp;lt;&amp;lt;cur-&amp;gt;data&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
            s.push(cur-&amp;gt;right);
            s.push(cur-&amp;gt;left);
        }
    }
}

遍历结果为：1 2 4 5 7 8 3 6
前序遍历方法二（非递归）
现在我们换一种思路来实现前序非递归遍历，仔细观察前序遍历的递归调用过程。

先把从根结点开始的所有左子树放入栈中；
弹出栈顶元素
如果栈顶元素有右子树，那么右子树入栈
重复上述过程直到栈为空

因此我们可以写出遍历代码
// 前序遍历 根左右
void pre_order_traversal(node *root)
{
    stack&amp;lt;node *&amp;gt; s;
    node *cur = root;

    while(cur || !s.empty()) {
        // 将左子树全部入栈
        while(cur) {
            cout&amp;lt;&amp;lt;cur-&amp;gt;data&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
            s.push(cur);
            cur = cur-&amp;gt;left;
        }

        if(!s.empty()) {
            cur = s.top();
            s.pop();
            cur = cur-&amp;gt;right;
        }
    }
}

遍历结果为：1 2 4 5 7 8 3 6
中序遍历（非递归）
有了前面的基础，我们再来考虑中序遍历，会发现中序遍历与前序遍历只是打印结点的位置不一样。前序遍历是在结点入栈时打印，中序遍历只需要替换为在结点出栈时打印即可。
// 中序遍历 左根右
void in_order_traversal(node *root)
{
    stack&amp;lt;node *&amp;gt; s;
    node *cur = root;

    while(cur || !s.empty()) {
        // 将左子树全部入栈
        while(cur) {
            s.push(cur);
            cur = cur-&amp;gt;left;
        }

        if(!s.empty()) {
            cur = s.top();
            cout&amp;lt;&amp;lt;cur-&amp;gt;data&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
            s.pop();
            cur = cur-&amp;gt;right;
        }
    }
}

遍历结果为：4 2 7 5 8 1 3 6
后序遍历方法一（非递归）
后序遍历相对来说显得更加复杂了。在前序和中序遍历中，只要左子树处理完毕实际上栈顶元素就可以出栈了，但后序遍历需要把左子树和右子树都处理完毕才能出栈，显然我们需要某种方法记录遍历的过程。
实际上我们只需要记录下遍历的前一个结点就能解决问题，因为通过前一个结点我们可以做如下判断：

如果前一个结点是当前结点的右子树，那么说明右子树已经遍历完毕可以出栈了
如果前一个结点是当前结点的左子树而且当前结点没有右子树，那么说明可以出栈了
如果当前结点即没有左子树也没有右子树，即为叶子结点，那么说明可以出栈了

若不属于上述情况，则依次将当前结点的右孩子和做孩子入栈，这样就能保证每次取栈顶元素时，左孩子都在右孩子前面被访问，左孩子和右孩子都在父结点前面被访问。
// 后序遍历 左右根
void post_order_traversal(node *root)
{
    stack&amp;lt;node *&amp;gt; s;
    node *pre = NULL;
    node *cur = root;

    s.push(cur);

    while(!s.empty()) {
        cur = s.top();
        // 叶子结点
        if((!cur-&amp;gt;left &amp;amp;&amp;amp; !cur-&amp;gt;right) // 叶子结点
        || pre == cur-&amp;gt;right // 前一个结点为当前结点右子树
        || (pre == cur-&amp;gt;left &amp;amp;&amp;amp; !cur-&amp;gt;right)) { // 前一个结点为当前结点左子树，且没有右子树
            cout&amp;lt;&amp;lt;cur-&amp;gt;data&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
            pre = cur;
            s.pop();
        } else {
            if(cur-&amp;gt;right)
                s.push(cur-&amp;gt;right);

            if(cur-&amp;gt;left)
                s.push(cur-&amp;gt;left);
        }
    }
}

遍历结果为：4 7 8 5 2 6 3 1
后序遍历方法二（非递归）
后序遍历的顺序是左右根，如果把这个顺序倒过来就是根右左，是不是发现和前序遍历很像？那么我只需要按照根右左的方式遍历完，然后将遍历结果掉一个个儿就可以，而栈就具备掉个儿的功能，因此可写出如下代码。
// 后序遍历 左右根
void post_order_traversal(node *root)
{
    stack&amp;lt;node *&amp;gt; s;
    stack&amp;lt;int&amp;gt; ans;
    node *cur = root;

    while(cur || !s.empty()) {
        // 将左子树全部入栈
        while(cur) {
            ans.push(cur-&amp;gt;data);
            s.push(cur);
            cur = cur-&amp;gt;right;
        }

        if(!s.empty()) {
            cur = s.top();
            s.pop();
            cur = cur-&amp;gt;left;
        }
    }

    while(!ans.empty()) {
        cout&amp;lt;&amp;lt;ans.top()&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
        ans.pop();
    }
}

遍历结果为：4 7 8 5 2 6 3 1
层序遍历
层序遍历即广度优先遍历，使用队列即可实现。
// 层序遍历
void breadth_first_order_traversal(node *root)
{
    queue&amp;lt;node *&amp;gt; q;
    q.push(root);
	while(!q.empty()){
		node *cur = q.front();
		q.pop();
		if(cur){
			cout&amp;lt;&amp;lt;cur-&amp;gt;data&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
			q.push(cur-&amp;gt;left);
			q.push(cur-&amp;gt;right);
		}
	}
}

遍历结果为：1 2 3 4 5 6 7 8

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/8sxCrqU9f/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/s3CKW7x7C/">
                        预处理器
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2022-11-06</time>
                    
                        <a href="https://www.guanngxu.com/umBdDP7Ll/" class="post-tag i-tag
                            i-tag-primary">
            #C
        </a>
                        
                        <a href="https://www.guanngxu.com/mZ_iBKmVWo/" class="post-tag i-tag
                            i-tag-other_1">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/s3CKW7x7C/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/s3CKW7x7C.png) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            C 语言的编译需要经过很多步骤，其中第一个步骤称为预处理阶段。这个阶段的主要任务包括删除注释、插入被#include指令包含的文件的内容、定义和替换#define指令定义的符号以及确定代码的部分内容是否应该跟绝一些条件编译指令进行编译。
#define
#define指令就是为数值命名一个符号。比如#define name stuff指令，有了它之后，每当有符号name出现在这条指令后面时，预处理器就会把它替换成stuff，比如下面几个例子：
// 为关键字 register 创建了一个简短的别名
#define reg             register
// 声明了一个更具描述性的符号用来替代实现无限循环的 for 语句
#define do_forever      for(;;)
// 定义了一个简短记法，在 switch 语句中使用，可以自动把一个 break 放在每个 case 之前
#define CASE            break;case

当然如果定义中的stuff非常长，那么也可以将它分成几行，除了最后一行之外，每行的末尾都需要加一个反斜杠。比如：
#define log_debug   printf(&amp;quot;File[%s]line[%d]:&amp;quot; \
                    &amp;quot; x=[%d], y=[%d], z=[%d]&amp;quot;, \
                    __FILE__, __LINE__, \
                    x, y, z)

// 那么我们将可以很方便的插入一条调试语句打印
x *= 2;
y += x;
z = x * y;
log_debug;

很容易就发现上面的log_debug定义无法进行泛化，当然设计者也考虑到了这个问题，所以#define机制包括了一个规定，即允许把参数替换到文本中，这种实现一般称为宏，其声明方式如下：
define name(parameter-list) stuff

需要注意的是parameter-list是一个由逗号分隔的符号列表，他们可能出现在stuff中。参数列表的左括号必须与name紧邻，如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分。下面我们看一个具体的列子，以此了解宏定义的机制，并将它逐步优化改进：
#define SQUARE(x)   x * x

// 使用
SQUARE(5)
// 效果：5 * 5

考虑一下下面的代码段：
a = 5;
printf(&amp;quot;%d\n&amp;quot;, SQUARE(a + 1));

乍一看觉得这段代码将打印36这个值。但实际它却会打印11，我们仔细观察一下被替换的宏文本，即参数x被文本a + 1替换：
a = 5;
printf(&amp;quot;%d\n&amp;quot;, a + 1 * a + 1);

很容易想到对参数 x 加一个括号解决上述问题，即：
#define SQUARE(x)   (x) * (x)

// 上述打印将会被替换为
a = 5;
printf(&amp;quot;%d\n&amp;quot;, (a + 1) * (a + 1));

类似的我们可以再定义一个DOUBLE宏，即：
#define DOUBLE(x)   (x) + (x)

但是考虑下面的使用方式：
a = 5;
printf(&amp;quot;%d\n&amp;quot;, 10 * DOUBLE(5));

看上去它应该打印的结果是100，但事实上它打印的是55，我们再通过宏替换产生的文本观察问题：
printf(&amp;quot;%d\n&amp;quot;, 10 * (5) + (5));

所以我们需要在整个表达式两边加上一对括号。所有用于对数值表达式进行求值的宏定义都应该使用下面这种方式加上括号，避免在使用宏时，由于参数中的操作符或邻近的操作符之间不可预料的相互作用。
#define DOUBLE(x)   ((x) + (x))

宏与函数
宏非常频繁的用于执行简单的计算，比如在两个表达式中寻找其中较大（小）的一个：
#define MAX(a, b)   ((a) &amp;gt; (b) ? (a) : (b))

那么为什么不使用函数来完成这个任务呢？首先用于调用和从函数返回的代码很可能比实际执行这个小型计算工作的代码更大，所以使用宏比使用函数在程序的规模和速度方面都更胜一筹。
更为重要的是函数必须声明为一种特定的类型，所以它只能在类型合适的表达式上使用。但是上面的这个宏可以用于整型、长整型、单浮点型、双浮点型以及任何其它可以使用&amp;gt;操作符比较值大小的类型，即宏与类型无关。
当然宏也有它的不利之处，因为每次在使用宏时，一份宏定义代码的拷贝都将插入到程序中，除非宏的定义非常短，否则使用宏将会大幅增加程序的长度。
也有一些任务根本无法使用函数实现，比如下面这个宏的第二个参数是一种类型，它无法作为函数参数进行传递。
#define MALLOC(n, type) ((type *)malloc((n) * sizeof(type)))

当宏参数在宏定义中出现的次数超过一次时，如果这个参数具有副作用，那么当使用这个宏的时候就可能出现危险，导致一些不可预料的后果。比如x++就是一个具有副作用的表达式，它会改变x的值，直接会导致下面的代码段出现不可预知的后果：
#define MAX(a, b)   ((a) &amp;gt; (b) &amp;gt; (a) : (b))

x = 5;
y = 8;
z = MAX(x++, y++);
// z = ((x++) &amp;gt; (y++) &amp;gt; (x++) : (y++))




属性
#define 宏
函数




代码长度
每次使用时，宏代码都被插入到程序中。除了非常小的宏志伟，程序的长度将大幅度增长
函数代码只出现于一个地方，每次使用这个函数时，都调用那个地方的同一份代码


执行速度
更快
存在函数调用/返回的额外开销


操作符优先级
宏参数的求值是在所有周围表达式的上下文环境里，除非它们加上括号，否则邻近操作符的优先级可能回产生不可预料的结果
函数参数只在函数调用时求值一次，它的结果传递给参数。表达式的求值结果更容易预测


参数求值
参数每次用于宏定义时，它们都将重新求值。由于多次求值，具有副作用的参数可能会产生不可预料的结果
参数在函数被调用前求值一次。在函数中多次使用参数并不会导致多种求值过程。参数的副作用不会造成任何特殊的问题


参数类型
宏与类型无关。只要对参数的操作是合法的，它可以使用于任何参数类型
函数的参数是与类型有关的。如果参数的类型不同，就需要使用不同的函数，即使它们执行的任务时相同的



文件包含
我们知道#include指令可以使另一个文件的内容被编译，就像它实际出现于#include指令出现的位置一样。这种替换的执行方式很简单：预处理器删除这条指令，并用包含头文件的内容取而代之。这样一个头文件如果被包含到 10 个源文件中，它实际上被编译了 10 次。
基于这种替换的方式，当出现嵌套#include文件被多次包含时，就会出现问题：
#include &amp;quot;a.h&amp;quot;
#include &amp;quot;b.h&amp;quot;

// 如果 a.h 和 b.h 中都包含一个 #include x.h
// 那么 x.h 在此处就出现了两次

这种多重包含在绝大多数情况下出现于大型程序中，它往往需要很多头文件，所以要发现这种情况并不容易。但是我们可以使用条件编译来解决这个问题：
#ifndef _HEADER_NAME_H_
#define _HEADER_NAME_H_

/*
* All the stuff that you want in the header file
*/

#endif


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/s3CKW7x7C/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/cCUDwnJ69/">
                        C 语言拾遗
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2022-10-16</time>
                    
                        <a href="https://www.guanngxu.com/vnEfA3xxL/" class="post-tag i-tag
                            i-tag-primary">
            #嵌入式
        </a>
                        
                        <a href="https://www.guanngxu.com/umBdDP7Ll/" class="post-tag i-tag
                            i-tag-other_1">
            #C
        </a>
                        
                        <a href="https://www.guanngxu.com/mZ_iBKmVWo/" class="post-tag i-tag
                            i-tag-other_4">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/cCUDwnJ69/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/cCUDwnJ69.png) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
约定：本文所说的标准均为 ANSI (C89) 标准

三字母词
标准定义了几个三字母词，三字母词就是三个字符的序列，合起来表示另一个字符。三字母词使得 C 环境可以在某些缺少一些必需字符的字符集上实现，它使用两个问号开头再尾随一个字符，这种形式一般不会出现在其它表达形式中，这样就不容易引起误解了，下面是一些三字母词的对应关系：
??(   [
??)   ]
??!   |
??&amp;lt;   {
??&amp;gt;   }
??&#39;   ^
??=   #
??/   \
??-   ~

所以在一些特殊情况下可能出现下面的情况，希望你不要被意外到。
printf(&amp;quot;Delete file (are you really sure??): &amp;quot;);

// result is: Delete file (are you really sure]: 

字符
直接操作字符会降低代码的可移植性，应该尽可能使用库函数完成。比如下面的代码试图测试ch是否为一个大写字符，它在使用ASCII字符集的机器上能够运行，但是在使用EBCDIC字符集的机器上将会失败。
if( ch &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; ch &amp;lt;= &#39;Z&#39;)

使用if(isupper(ch))语句则能保证无论在哪种机器上都能正常运行。
字符串比较
库函数提供了int strcmp(const char *s1, const char *s2)函数用于比较两个字符串是否相等，需要注意的是在标准中并没有规定用于提示不相等的具体值。它只是说如果第 1 个字符串大于第 2 个字符串就返回一个大于零的值，如果第 1 个字符串小于第 2 个字符串就返回一个小于零的值。一个常见的错误是以为返回值是1和-1，分别代表大于和小于。
初学者常常会编写下面的表达式。认为如果两个字符串相等，那么它返回的结果将为真。但是这个结果恰好相反，两个字符串相等的情况下返回值是零（假）。
if(strcmp(a, b))

strlen
strlen的返回值是一个size_t类型的值，这个类型是在头文件stddef.h中定义的，它是一个无符号整数类型，所以会导致下面表达式的条件永远为真。
if(strlen(x) - strlen(y) &amp;gt;= 0) {
    // do something
}

第二点需要注意的是strlen的返回值没有计算\0的长度，所以下面的代码在一些检查严格或老版本的编译器中会报错，其原因在于少分配了一个存储单位。
// 假设 str 是一个字符串
char *cpy = malloc(strlen(str));
strcpy(cpy, str);

// 正确写法应为
char *cpy = malloc(strlen(str) + 1);
strcpy(cpy, str);

赋值截断
表达式a = x = y + 3;中x和a被赋予相同值的说法是错误的，因为如果x是一个字符型变量，那么y+3的值就会被截去一段，以便容纳于字符型的变量中，那么a所赋的值就是这个被截短后的值。下面也是一个非常常见的错误。
char ch;
// do something
while((ch = getchar()) != EOF) {
    // do something
}

EOF所需要的位数比字符型值所能提供的位数要多，这也是getchar返回一个整型值而不是字符值的原因。例子中把getchar的返回值存储于字符型变量会导致被截短，然后再把这个被截短的值提升为整型与EOF进行比较，在某些机器的特定场景下就会导致问题。比如在使用有符号字符集的机器上，如果读取了一个的值为\377的字节，上述循环就将终止，因为这个值截短再提升之后与EOF相等。而当这段代码在使用无符号字符集的机器上运行时，这个循环将永远不会终止。
指针与数组
因为数组和指针都具有指针值，都可以进行间接访问和下标操作，所以很多同学都想当然的将它们认为是一样的，为了说明它们是不相等的，我们可以考虑下面的两个声明：
int a[5];
int *b;

声明一个数组时，编译器将根据声明所指定的元素数量为数组保留空间，然后再创建数组名，它的值是一个常量，指向这段空间的起始位置。声明一个指针变量时，编译器只为指针本身保留内存空间，它并不为任何整型值分配内存空间。而且，指针变量并未被初始化为任何指向现有的内存空间。所以在上述声明之后，表达式*a是完全合法的，但是表达式*b将访问内存中某个不确定的位置，或者导致程序终止。
硬件操作
我们知道其实表示就是内存中一个地址，所以理论上*100 = 25是一种可行的操作，即让内存中位置为100的地方存储25。但实际上这条语句是非法的，因为字面值100的类型是整型，而间接访问操作只能用于指针类型表达式，所以合法的写法必须使用强制转换，即*(int *)100 = 25。
需要说明的是使用这种技巧的机会是绝无仅有的，只有偶尔需要通过地址访问内存中某个特定的位置才可使用，它并不是访问某个变量，而是访问硬件本身。比如在某些机器上，操作系统需要与输入输出设备控制器通信，启动 I/O 操作并从前面的操作中获得结果，此时这些地址是预先已知的。
+= 与 ?: 操作符
我们在这里讨论一下+=操作符，它的用法为a += expr，读作把 expr 加到 a，其实际功能相当于表达式a = a + expr的作用，唯一不同的是+=操作符的左操作数a只会求值一次。可能到目前为止没有感觉到设计两种增加一个变量值的方法有什么意义？下面给出代码示例：
// 形式 1
a[ 2 * (y - 6*f(x)) ] = a[ 2 * (y - 6*f(x)) ] + 1;

// 形式 2
a[ 2 * (y - 6*f(x)) ] += 1;

在第一种形式中，用于选择增值位置的表达式必须书写两次，一次在赋值号左边，一次在赋值号右边。由于编译器无法知道函数f是否具有副作用，所以它必须两次计算下标表达式的值，而第二种形式的效率会更高，因为下标表达式的值只会被计算一次。同时第二种形式也减少了代码书写错误的概率。
同理三目运算符也可以起到类似的效果。
// 形式 1
if(a &amp;gt; 5) {
    b[ 2 * c + d * (e / 5) ] = 3;
} else {
    b[ 2 * c + d * (e / 5) ] = -20;
}

// 形式 2
b[ 2 * c + d * (e / 5) ] = a &amp;gt; 5 ? 3 : -20;

逗号操作符
逗号操作符可以将多个表达式分隔开来。这些表达式自左向右逐个进行求值，整个表达式的值就是最后那个表达式的值。例如：
if(b + 1, c / 2, d &amp;gt; 0) { // do something}

当然，正常人不会编写这样的代码，因为对前两个表达式的求值毫无意义，它们的值只是被简单的丢弃了。但是我们可以看看下面的代码：
// 形式 1
a = get_value();
count_value(a);
while(a &amp;gt; 0) {
    // do something
    a = get_value();
    count_value(a);
}

// 形式 2
while(a = get_value(), count_value(), a &amp;gt; 0) {
    // do something
}

指针
int* a, b, c;

人们会很自然的认为上述语句是把所有三个变量都声明为指向整型的指针，但事实上并非如此，星号实际上只是表达式*a的一部分，只对这个标识符有作用。如果要声明三个指针，那么应该使用下面的形式进行初始化。
int *a, *b, *c;

在声明指针变量时可以为它指定初始值，比如下面的代码段，它声明了一个指针，并用一个字符串常量对其进行初始化。
char *msg = &amp;quot;Hello World!&amp;quot;;

需要注意的是，这种类型的声明会让人很容易误解它的意思，看起来初始值似乎是赋给表达式*msg的，但实际上它是赋值给msg本身的，也就是上述声明实际形式如下：
char *msg;
msg = &amp;quot;Hello World!&amp;quot;;

指针常量： int *pi中pi是一个普通的指向整型的指针， 而变量int const *pci则是一个指向整型常量的指针，你可以修改指针的值，但是不能修改它所指向的值。相比之下int * const cpi则声明cpi为一个指向整型的常量指针。此时指针是常量，它的值无法修改，但是可以修改它所指向的整型的值。在int const * const cpci中，无论是指针本身还是它所指向的值都是常量，无法修改。
枚举类型
枚举（enumerated） 类型就是指它的的值为符号常量而不是字面值的类型，比如下面的语句声明了Jar_Type类型：
enum Jar_Type {
    CUP,
    PINT,
    QUART,
    HALF_GALLON,
    GALLON
};

需要注意的是，枚举类型实际上是以整型方式存储的，代码段中的符号名实际上都是整型值。在这里CUP的值是0，PINT的值是1，依次类推。
在适当的时候，可以为这些符号名指定特定的值整型值。并且只对部分符号名进行赋值也是合法的，如果某个符号名没有显示的赋值，那么它的值就比前面一个符号名的值大 1。
enum Jar_Type {
    CUP = 8,
    PINT = 16,
    QUART = 32,
    HALF_GALLON = 64,
    GALLON = 128
};


符号名被当作整型处理，这意味着可以把HALF_GALLON这样的值赋给任何整型变量，但是在编程活动中应该避免这种方式使用枚举，因为这样会削弱它们的含义。

typedef 与 define
在实际应用过程中应该使用typedef而不是#define来创建新的类型名，因为#define无法正确的处理指针类型，比如下面的代码段正确的声明了a，但是b却被声明为了一个字符。
#define ptr_to_char char *
ptr_to_char a, b;

联合（union）
联合看起来很像结构体，与结构体不同的是联合的所有成员共用同一块内存，所以在同一时刻联合中的有效成员永远只有一个。我们可以看下面一个例子，当一个variable类型的变量被创建时，解释器就创建一个这样的结构并记录变量类型。然后根据变量类型，把变量的值存储在这三个值字段的其中一个。
struct variable {
    enum { INT, FLOAT, STRING } type;
    int int_val;
    float float_val;
    char *str_val;
}

不难发现上述结构的低效之处在于它所使用的内存，每个variable结构存在两个未使用的值字段，造成了内存空间上的不少浪费。使用联合就可以减少这种空间上的浪费，它把这三个值字段的每一个都存储在同一个内存位置。我们知道这三个字段并不会冲突，因为每个变量只可能具有一种类型，所以在具体的某一时刻，联合的这几个字段只有一个被使用。
struct variable {
    enum { INT, FLOAT, STRING } type;
    union {
        int i;
        float f;
        char *s;
    } val;
}

现在，对于整型变量，我们只需要将type字段设为INT，并把整型值存储于val.i即可。如果联合中各成员的长度不一样，联合的长度就是它最长成员的长度。
联合的变量也可以被初始化，但是这个初始值必须是联合第 1 个成员的类型，而且它必须位于一对花括号里面。比如：
union {
    int a;
    float b;
    chat c[4];
} x = { 5 };

结构体
在实际编程活动中，存在链表、二叉树等结点自引用的情况，那么结构体的自引用如何编写呢？
struct node {
    int data;
    struct node next;
}

上述写法是非法的，因为成员next是一个完整的结构，其内部还将包含自己的成员next，这第 2 个成员又是另一个完整结构，它还将包含自己的成员next，如此重复下去将永无止境。正确的自引用写法如下：
struct node {
    int data;
    struct node *next;
}

我们需要注意下面的这个陷阱：
/*
错误写法：因为类型名 node_t 直到声明末尾才定义
所以在结构中声明的内部 node_t 尚未定义
*/
typedef struct {
    int data;
    node_t *next;
} node_t;

// 正确写法
typedef struct node_tag {
    int data;
    struct node_tag *next;
} node_t;

编译器在实际分配时会按照结构体成员列表的顺序一个接一个的分配内存，并且只有当存储成员需要满足正确的边界对齐要求时，成员之间可能会出现用于填充的额外内存空间。

```c
struct align {
    char a;
    int b;
    char c;
}

如果某个机器的整型值长度为 4 个字节，并且它的起始存储位置必须能够被 4 整除，那么这个结构在内存中的存储将是下面这种形式



a



b
b
b
b
c






我们可以通过改变成员列表的声明顺序，让那些对边界要求严格的成员首先出现，对边界要求弱的成员最后出现，这样可以减少因为边界对齐而带来的空间损失。
struct align {
    int b;
    char a;
    char c;
}




b
b
b
b
a
c



当程序创建几百个甚至几千个结构时，减少内存浪费的要求就比程序的可读性更为急迫。我们可以使用sizeof操作符来得出一个结构的整体长度。如果必须要确定结构某个成员的实际位置，则可以使用offsetof(type, member)宏，例如：
offset(struct align, b);

一句话
标识符：标识符就是变量、函数、类型等的名字，标识符的长度没有限制，但是 ANSI 标准允许编译器忽略第 31 个字符以后的字符，并且允许编译器对用于表示外部名字（由链接器操作的名字）的标识符进行限制，只识别前 6 位不区分大小写的字符。
注释：代码中所有的注释都会被预处理器拿掉，取而代之的是一个空格。因此，注释可以出现在任何空格可以出现的地方。
类型：C 语言中仅有 4 种基本数据类型，即整型、浮点型、指针和聚合类型（数组、结构等），所有其它的类型都是从这 4 中基本类型的某种组合派生而来。
类型长度：标准只规定了short int至少是 16 位，long int至少是 32 位，至于缺省的int是多少位则直接由编译器设计者决定。并且标准也没有规定这 2 个值必须不一样。如果某种机器的环境字长是 32 位，而且也没有什么指令能够更有效的处理更短的整型值，那它很可能把这 3 个整型值都设定为 32 位。
位域：基于 int 位域被当作有符号还是无符号数、位域成员的内存是从左向右还是从右向左分配、运行在 32 位整数的位域声明可能在 16 位机器无法运行等原因，注重可移植性的程序应该避免使用位域。
结构与指针：什么时候应该向函数传递一个结构而不是一个指向结构的指针呢？很少有这种情况。只有当一个结构特别小（长度和指针相同或更小）时，结构传递方案的效率才不会输给指针传递方案。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/cCUDwnJ69/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/ghceoN-RR/">
                        为什么宏定义要使用 do {...} while (0) ?
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2022-09-15</time>
                    
                        <a href="https://www.guanngxu.com/vnEfA3xxL/" class="post-tag i-tag
                            i-tag-">
            #嵌入式
        </a>
                        
                        <a href="https://www.guanngxu.com/umBdDP7Ll/" class="post-tag i-tag
                            i-tag-info">
            #C
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/ghceoN-RR/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/ghceoN-RR.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容:
do {…} while (0) in macros
do {...} while (0) 在宏定义中的作用
do{}while(0)只执行一次无意义？你可能真的没理解

近期参与的项目属于嵌入式软件领域，自然而然就得用 C 语言进行开发，开发过程中发现引入的第三方库里面有一些奇奇怪怪的写法，比如大佬们都喜欢使用do {...} while(0)的宏定义，在 Stack Overflow 上也有人提出了这个问题。之前从事 Linux 内核开发的谷歌大佬 Robert Love 给出了如下的解释：

do {…} while(0) is the only construct in C that lets you define macros that always work the same way, so that a semicolon after your macro always has the same effect, regardless of how the macro is used (with particularly emphasis on the issue of nesting the macro in an if without curly-brackets).
do {...} while(0) 在 C 中是唯一的构造程序，让你定义的宏总是以相同的方式工作，这样不管怎么使用宏（尤其在没有用大括号包围调用宏的语句），宏后面的分号也是相同的效果。

这句话读起来有些拗口，只觉得大佬的表述曲高和寡，翻译翻译就是：使用do {...} while(0)构造后的宏定义不会受到大括号、分号等影响，总能按照我们期望的方式调用运行。下面我们举几个实际的例子来加深理解。
// 现有如下宏定义
#define foo(x) bar(x); baz(x)

// 1. 可以这样调用
foo(wolf);

// 上述调用将会被展开为下列代码，完美没有问题
bar(wolf); baz(wolf);


// 2. 如果我们像下面这样调用呢？
if (!feral)
    foo(wolf);

// 上述调用将会被展开为下列代码，很明显这是错误的，并且是很容易犯的错误
if (!feral)
    bar(wolf);
baz(wolf);

为了避免上面例子所出现的问题，我们可以考虑使用{ }直接把整个宏包裹起来，如下所示：
// 修改宏定义为
#define foo(x) { bar(x); baz(x) }

// 3. 例 1 调用
if (!feral)
    foo(wolf);

// 现在上述调用将展开为下列代码
if (!feral) {
    bar(wolf);
    baz(wolf);
};


// 4. 我们再考虑一下如下调用呢
if (!feral)
    foo(wolf);
else
    bin(wolf);

// 上述调用将会被展开为下列代码，很明显又出现了语法错误
if (!feral) {
    bar(wolf);
    baz(wolf);
};
else
    bin(wolf);

我们继续考虑比使用{ }直接把整个宏包裹起来更好的方法，即本文标题所说的使用do {...} while (0)，即上述宏将定义为如下形式。
// 终极版宏定义
#define foo(x) do { bar(x); baz(x) } while (0)

// 5. 例 4 调用
if (!feral)
    foo(wolf);
else
    bin(wolf);

// 现在上述调用将展开为下列形式，很完美
if (!feral)
    do { bar(wolf); baz(wolf) } while (0);
else
    bin(wolf);

do {...} while (0)除了在宏定义中可以发挥完美的作用外，在某些情况下还可以当作goto使用。因为goto不符合软件工程的结构化，并且容易使得代码晦涩难懂，所以很多公司都不倡导使用甚至禁止使用。那么我们可以使用do {...} while (0)来做同样的事情。
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
int main()
{
   char *str;
   /* 最初的内存分配 */
   str = (char *) malloc(15);
   if(str != NULL)
     goto loop;
   printf(&amp;quot;hello world\n&amp;quot;);
loop:
   printf(&amp;quot;malloc success\n&amp;quot;);
   return 0;
}

上述代码我们可以修改为下列形式，使用do {...} while (0)将函数主体包裹起来，而break语句则替代了goto语句的作用，并且代码的可读性与可维护性都比上述goto方式更好。
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
int main()
{
  do{
      char *str;
      /* 最初的内存分配 */
      str = (char *) malloc(15);
      if(str != NULL)
       break;
      printf(&amp;quot;hello world\n&amp;quot;);
  }while(0);
   printf(&amp;quot;malloc success\n&amp;quot;);
   return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/ghceoN-RR/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                

                <!-- 金山词霸 -->
                <!-- <script>
                    const date = new Date();
                    const today = date.toISOString().substring(0, 10);
                    console.info(today)
                    $.ajax({
                        url: `http://sentence.iciba.com/index.php?c=dailysentence&m=getdetail&title=${today}`,
                        type: "GET",
                        dataType: "jsonp", //指定服务器返回的数据类型
                        success: function (data) {
                            $(".null-feature-image").css("background-image", `url(${data.picture2})`);
                            console.log(data);
                        }
                    });
                </script> -->
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar">
            <img src="https://www.guanngxu.com/images/avatar.png?v=1769266443907">
        </div>
        <h1 class="id_card-title">
            Guanngxu
        </h1>
        <h2 class="id_card-description">
            Keep trying
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                <a href="https://github.com/Guanngxu" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-github"></i></a>
                
                    <!-- twitter -->
                    
                        <a href="https://twitter.com/guanngxu" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-twitter"></i></a>
                        
                            <!-- weibo -->
                            
                                <a href="https://weibo.com/u/5288280194" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-weibo"></i></a>
                                
                                    <!-- facebook -->
                                    
                                        <!-- douban -->
                                        
                                            <a href="https://www.douban.com/people/Guanngxu" target="_blank" rel="noopener noreferrer">
                                                <svg t="1660751300927" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2563" width="200" height="200"><path d="M1023.979 862.827A161.152 161.152 0 0 1 862.805 1024H161.173A161.152 161.152 0 0 1 0 862.827V161.195A161.195 161.195 0 0 1 161.173 0.02h701.632a161.195 161.195 0 0 1 161.174 161.174v701.632z" fill="#515151" p-id="2564" data-spm-anchor-id="a313x.7781069.0.i2" class="selected"></path><path d="M218.56 208.064h586.816v66.09H218.56z m535.83 393.493v-258.41h-484.8v258.41h484.8zM339.882 409.173H684.8v126.358H339.883V409.173z m309.61 341.334c21.099-32.299 41.003-69.739 59.435-112.256l-70.507-25.707c-18.346 50.368-39.701 96.427-64 137.941H451.712c-20.373-53.802-43.328-99.818-69.077-137.941l-64.854 25.707c26.752 40.128 48.32 77.482 64.854 112.256H201.94v65.386h620.054v-65.386H649.493z" fill="#FFFFFF" p-id="2565" data-spm-anchor-id="a313x.7781069.0.i3" class=""></path></svg>
                                            </a>
                                        

        </div>
    </div>
    
    <script>
        // const date = new Date();
        // const today = date.toISOString().substring(0, 10);
        // console.info(today)
        // $.ajax({
        //     url: `http://sentence.iciba.com/index.php?c=dailysentence&m=getdetail&title=${today}`,
        //     type: "GET",
        //     dataType: "jsonp", //指定服务器返回的数据类型
        //     success: function (data) {
        //         $(".id_card-description").text(data.content)
        //         console.log(data);
        //     }
        // });
    </script>

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  <a href="https://beian.miit.gov.cn" target="_blank">蜀ICP备2022021904号</a> | 
  <a class="rss" href="https://www.guanngxu.com/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>