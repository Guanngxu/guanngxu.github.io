<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    嵌入式 | Guanngxu
</title>
<link rel="shortcut icon" href="https://www.guanngxu.com/favicon.ico?v=1769266443907">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://www.guanngxu.com/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://www.guanngxu.com/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7393078395398753" crossorigin="anonymous"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://www.guanngxu.com">
                <img class="avatar" src="https://www.guanngxu.com/images/avatar.png?v=1769266443907" alt="">
            </a>
            <a href="https://www.guanngxu.com">
                <div class="site-title">
                    <h1>
                        Guanngxu
                    </h1>
                </div>
            </a>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                        <li>
                            <a href="/about" class="menu" target="_blank">
                                关于
                            </a>
                        </li>
                        
                                
                    
                            <li>
                                <a href="https://guanngxu.com/uAv93EeJY" class="menu">
                                    工具
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
    <div class="i-card">
        <b>标签：#
        嵌入式</b>
    </div>
    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/7pUUwIeSw/">
                        Linux 创建实时进程
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2023-11-28</time>
                    
                        <a href="https://www.guanngxu.com/vnEfA3xxL/" class="post-tag i-tag
                            i-tag-success">
            #嵌入式
        </a>
                        
                        <a href="https://www.guanngxu.com/umBdDP7Ll/" class="post-tag i-tag
                            i-tag-banana">
            #C
        </a>
                        
                        <a href="https://www.guanngxu.com/mZ_iBKmVWo/" class="post-tag i-tag
                            i-tag-primary">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/7pUUwIeSw/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/7pUUwIeSw.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
深入理解LINUX内核(第三版)
linux 创建实时进程
深入 Linux 的进程优先级
Linux进程优先级系统——设置实时进程优先级

Linux 系统的调度基于分时技术，

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/7pUUwIeSw/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/RYkQYSFKV/">
                        linux-5.10.157 内核源码编译
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2022-12-08</time>
                    
                        <a href="https://www.guanngxu.com/vnEfA3xxL/" class="post-tag i-tag
                            i-tag-success">
            #嵌入式
        </a>
                        
                        <a href="https://www.guanngxu.com/mZ_iBKmVWo/" class="post-tag i-tag
                            i-tag-warning">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/RYkQYSFKV/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/RYkQYSFKV.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
Linux内核开发_1_编译LInux内核
编译linux内核报错：flex: not foundscripts
编译kernel5.14报错fatal error: openssl/opensslv.h
编译内核错误——*** 没有规则可制作目标“debian/canonical-certs.pem”
内核错误：BTF: .tmp_vmlinux.btf: pahole (pahole) is not available

# 切换到 root 账户
sudo su

# 查看操作系统版本
cat /etc/issue

# 查看 Linux 内核版本
cat /proc/version

# 进入 root 账户目录
cd /home/root

# 下载 Linux 内核源码
wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.157.tar.xz
# Linux 其它版本源码 https://www.kernel.org/

# xz 解压
xz -d linux-5.10.157.tar.xz

# tar 解压到 /usr/src/linux-5.10.157 目录下
tar -xf linux-5.10.157.tar -C /usr/src/.

# 进入源码目录
cd /usr/src/linux-5.10.157

# 查看源码结构
tree . -L 2

# 若没有 tree 命令，可以执行下面命令
# apt-get install tree

# 配置编译选项
make menuconfig

# 若没有 make，可以执行下面命令
# apt-get install make

# 若执行 make 后报错找不到 curses.h，可以执行下面命令
# apt-get install libncurses5-dev

# 若报错找不到 flex not found，可以执行下面两条命令
# apt-get install flex
# apt-get install bison

# 再次运行 make menuconfig 弹出图形化配置页面后
# 若使用默认配置，则直接按两次 Esc 键退出即可
# 此时会在当前目录下生成 .config 文件

# 编译 Linux 源码
make bzImage -j4

# 在编译过程中若报错 fatal error: openssl/opensslv.h，可执行下面命令
# apt-get install libssl-dev
# 若还出现同样的问题，可参考 https://blog.csdn.net/ComputerInBook/article/details/107380796 源码编译安装 openssl

# 若出现「没有规则可制作目标“debian/canonical-certs.pem”」报错
# 需要删除 .config 中相应的字段，总共有两处
# 一处为 CONFIG_SYSTEM_TRUSTED_KEYS=&amp;quot;debian/canonical-certs.pem&amp;quot;
# 一处为 CONFIG_SYSTEM_REVOCATION_KEYS=&amp;quot;debian/canonical-revoked-certs.pem&amp;quot;

vim .config
# 删除之后的样子如下（需要保留引号）：
# 一处为 CONFIG_SYSTEM_TRUSTED_KEYS=&amp;quot;&amp;quot;
# 一处为 CONFIG_SYSTEM_REVOCATION_KEYS=&amp;quot;&amp;quot;

# 若出现 BTF: .tmp_vmlinux.btf: pahole (pahole) is not available 错误，则执行下面命令
# apt-get install dwarves

# 若在过程中还出现其它问题，大多是因为缺少相关库导致的，直接用 apt-get install 即可


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/RYkQYSFKV/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/cCUDwnJ69/">
                        C 语言拾遗
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2022-10-16</time>
                    
                        <a href="https://www.guanngxu.com/vnEfA3xxL/" class="post-tag i-tag
                            i-tag-info">
            #嵌入式
        </a>
                        
                        <a href="https://www.guanngxu.com/umBdDP7Ll/" class="post-tag i-tag
                            i-tag-info">
            #C
        </a>
                        
                        <a href="https://www.guanngxu.com/mZ_iBKmVWo/" class="post-tag i-tag
                            i-tag-">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/cCUDwnJ69/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/cCUDwnJ69.png) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
约定：本文所说的标准均为 ANSI (C89) 标准

三字母词
标准定义了几个三字母词，三字母词就是三个字符的序列，合起来表示另一个字符。三字母词使得 C 环境可以在某些缺少一些必需字符的字符集上实现，它使用两个问号开头再尾随一个字符，这种形式一般不会出现在其它表达形式中，这样就不容易引起误解了，下面是一些三字母词的对应关系：
??(   [
??)   ]
??!   |
??&amp;lt;   {
??&amp;gt;   }
??&#39;   ^
??=   #
??/   \
??-   ~

所以在一些特殊情况下可能出现下面的情况，希望你不要被意外到。
printf(&amp;quot;Delete file (are you really sure??): &amp;quot;);

// result is: Delete file (are you really sure]: 

字符
直接操作字符会降低代码的可移植性，应该尽可能使用库函数完成。比如下面的代码试图测试ch是否为一个大写字符，它在使用ASCII字符集的机器上能够运行，但是在使用EBCDIC字符集的机器上将会失败。
if( ch &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; ch &amp;lt;= &#39;Z&#39;)

使用if(isupper(ch))语句则能保证无论在哪种机器上都能正常运行。
字符串比较
库函数提供了int strcmp(const char *s1, const char *s2)函数用于比较两个字符串是否相等，需要注意的是在标准中并没有规定用于提示不相等的具体值。它只是说如果第 1 个字符串大于第 2 个字符串就返回一个大于零的值，如果第 1 个字符串小于第 2 个字符串就返回一个小于零的值。一个常见的错误是以为返回值是1和-1，分别代表大于和小于。
初学者常常会编写下面的表达式。认为如果两个字符串相等，那么它返回的结果将为真。但是这个结果恰好相反，两个字符串相等的情况下返回值是零（假）。
if(strcmp(a, b))

strlen
strlen的返回值是一个size_t类型的值，这个类型是在头文件stddef.h中定义的，它是一个无符号整数类型，所以会导致下面表达式的条件永远为真。
if(strlen(x) - strlen(y) &amp;gt;= 0) {
    // do something
}

第二点需要注意的是strlen的返回值没有计算\0的长度，所以下面的代码在一些检查严格或老版本的编译器中会报错，其原因在于少分配了一个存储单位。
// 假设 str 是一个字符串
char *cpy = malloc(strlen(str));
strcpy(cpy, str);

// 正确写法应为
char *cpy = malloc(strlen(str) + 1);
strcpy(cpy, str);

赋值截断
表达式a = x = y + 3;中x和a被赋予相同值的说法是错误的，因为如果x是一个字符型变量，那么y+3的值就会被截去一段，以便容纳于字符型的变量中，那么a所赋的值就是这个被截短后的值。下面也是一个非常常见的错误。
char ch;
// do something
while((ch = getchar()) != EOF) {
    // do something
}

EOF所需要的位数比字符型值所能提供的位数要多，这也是getchar返回一个整型值而不是字符值的原因。例子中把getchar的返回值存储于字符型变量会导致被截短，然后再把这个被截短的值提升为整型与EOF进行比较，在某些机器的特定场景下就会导致问题。比如在使用有符号字符集的机器上，如果读取了一个的值为\377的字节，上述循环就将终止，因为这个值截短再提升之后与EOF相等。而当这段代码在使用无符号字符集的机器上运行时，这个循环将永远不会终止。
指针与数组
因为数组和指针都具有指针值，都可以进行间接访问和下标操作，所以很多同学都想当然的将它们认为是一样的，为了说明它们是不相等的，我们可以考虑下面的两个声明：
int a[5];
int *b;

声明一个数组时，编译器将根据声明所指定的元素数量为数组保留空间，然后再创建数组名，它的值是一个常量，指向这段空间的起始位置。声明一个指针变量时，编译器只为指针本身保留内存空间，它并不为任何整型值分配内存空间。而且，指针变量并未被初始化为任何指向现有的内存空间。所以在上述声明之后，表达式*a是完全合法的，但是表达式*b将访问内存中某个不确定的位置，或者导致程序终止。
硬件操作
我们知道其实表示就是内存中一个地址，所以理论上*100 = 25是一种可行的操作，即让内存中位置为100的地方存储25。但实际上这条语句是非法的，因为字面值100的类型是整型，而间接访问操作只能用于指针类型表达式，所以合法的写法必须使用强制转换，即*(int *)100 = 25。
需要说明的是使用这种技巧的机会是绝无仅有的，只有偶尔需要通过地址访问内存中某个特定的位置才可使用，它并不是访问某个变量，而是访问硬件本身。比如在某些机器上，操作系统需要与输入输出设备控制器通信，启动 I/O 操作并从前面的操作中获得结果，此时这些地址是预先已知的。
+= 与 ?: 操作符
我们在这里讨论一下+=操作符，它的用法为a += expr，读作把 expr 加到 a，其实际功能相当于表达式a = a + expr的作用，唯一不同的是+=操作符的左操作数a只会求值一次。可能到目前为止没有感觉到设计两种增加一个变量值的方法有什么意义？下面给出代码示例：
// 形式 1
a[ 2 * (y - 6*f(x)) ] = a[ 2 * (y - 6*f(x)) ] + 1;

// 形式 2
a[ 2 * (y - 6*f(x)) ] += 1;

在第一种形式中，用于选择增值位置的表达式必须书写两次，一次在赋值号左边，一次在赋值号右边。由于编译器无法知道函数f是否具有副作用，所以它必须两次计算下标表达式的值，而第二种形式的效率会更高，因为下标表达式的值只会被计算一次。同时第二种形式也减少了代码书写错误的概率。
同理三目运算符也可以起到类似的效果。
// 形式 1
if(a &amp;gt; 5) {
    b[ 2 * c + d * (e / 5) ] = 3;
} else {
    b[ 2 * c + d * (e / 5) ] = -20;
}

// 形式 2
b[ 2 * c + d * (e / 5) ] = a &amp;gt; 5 ? 3 : -20;

逗号操作符
逗号操作符可以将多个表达式分隔开来。这些表达式自左向右逐个进行求值，整个表达式的值就是最后那个表达式的值。例如：
if(b + 1, c / 2, d &amp;gt; 0) { // do something}

当然，正常人不会编写这样的代码，因为对前两个表达式的求值毫无意义，它们的值只是被简单的丢弃了。但是我们可以看看下面的代码：
// 形式 1
a = get_value();
count_value(a);
while(a &amp;gt; 0) {
    // do something
    a = get_value();
    count_value(a);
}

// 形式 2
while(a = get_value(), count_value(), a &amp;gt; 0) {
    // do something
}

指针
int* a, b, c;

人们会很自然的认为上述语句是把所有三个变量都声明为指向整型的指针，但事实上并非如此，星号实际上只是表达式*a的一部分，只对这个标识符有作用。如果要声明三个指针，那么应该使用下面的形式进行初始化。
int *a, *b, *c;

在声明指针变量时可以为它指定初始值，比如下面的代码段，它声明了一个指针，并用一个字符串常量对其进行初始化。
char *msg = &amp;quot;Hello World!&amp;quot;;

需要注意的是，这种类型的声明会让人很容易误解它的意思，看起来初始值似乎是赋给表达式*msg的，但实际上它是赋值给msg本身的，也就是上述声明实际形式如下：
char *msg;
msg = &amp;quot;Hello World!&amp;quot;;

指针常量： int *pi中pi是一个普通的指向整型的指针， 而变量int const *pci则是一个指向整型常量的指针，你可以修改指针的值，但是不能修改它所指向的值。相比之下int * const cpi则声明cpi为一个指向整型的常量指针。此时指针是常量，它的值无法修改，但是可以修改它所指向的整型的值。在int const * const cpci中，无论是指针本身还是它所指向的值都是常量，无法修改。
枚举类型
枚举（enumerated） 类型就是指它的的值为符号常量而不是字面值的类型，比如下面的语句声明了Jar_Type类型：
enum Jar_Type {
    CUP,
    PINT,
    QUART,
    HALF_GALLON,
    GALLON
};

需要注意的是，枚举类型实际上是以整型方式存储的，代码段中的符号名实际上都是整型值。在这里CUP的值是0，PINT的值是1，依次类推。
在适当的时候，可以为这些符号名指定特定的值整型值。并且只对部分符号名进行赋值也是合法的，如果某个符号名没有显示的赋值，那么它的值就比前面一个符号名的值大 1。
enum Jar_Type {
    CUP = 8,
    PINT = 16,
    QUART = 32,
    HALF_GALLON = 64,
    GALLON = 128
};


符号名被当作整型处理，这意味着可以把HALF_GALLON这样的值赋给任何整型变量，但是在编程活动中应该避免这种方式使用枚举，因为这样会削弱它们的含义。

typedef 与 define
在实际应用过程中应该使用typedef而不是#define来创建新的类型名，因为#define无法正确的处理指针类型，比如下面的代码段正确的声明了a，但是b却被声明为了一个字符。
#define ptr_to_char char *
ptr_to_char a, b;

联合（union）
联合看起来很像结构体，与结构体不同的是联合的所有成员共用同一块内存，所以在同一时刻联合中的有效成员永远只有一个。我们可以看下面一个例子，当一个variable类型的变量被创建时，解释器就创建一个这样的结构并记录变量类型。然后根据变量类型，把变量的值存储在这三个值字段的其中一个。
struct variable {
    enum { INT, FLOAT, STRING } type;
    int int_val;
    float float_val;
    char *str_val;
}

不难发现上述结构的低效之处在于它所使用的内存，每个variable结构存在两个未使用的值字段，造成了内存空间上的不少浪费。使用联合就可以减少这种空间上的浪费，它把这三个值字段的每一个都存储在同一个内存位置。我们知道这三个字段并不会冲突，因为每个变量只可能具有一种类型，所以在具体的某一时刻，联合的这几个字段只有一个被使用。
struct variable {
    enum { INT, FLOAT, STRING } type;
    union {
        int i;
        float f;
        char *s;
    } val;
}

现在，对于整型变量，我们只需要将type字段设为INT，并把整型值存储于val.i即可。如果联合中各成员的长度不一样，联合的长度就是它最长成员的长度。
联合的变量也可以被初始化，但是这个初始值必须是联合第 1 个成员的类型，而且它必须位于一对花括号里面。比如：
union {
    int a;
    float b;
    chat c[4];
} x = { 5 };

结构体
在实际编程活动中，存在链表、二叉树等结点自引用的情况，那么结构体的自引用如何编写呢？
struct node {
    int data;
    struct node next;
}

上述写法是非法的，因为成员next是一个完整的结构，其内部还将包含自己的成员next，这第 2 个成员又是另一个完整结构，它还将包含自己的成员next，如此重复下去将永无止境。正确的自引用写法如下：
struct node {
    int data;
    struct node *next;
}

我们需要注意下面的这个陷阱：
/*
错误写法：因为类型名 node_t 直到声明末尾才定义
所以在结构中声明的内部 node_t 尚未定义
*/
typedef struct {
    int data;
    node_t *next;
} node_t;

// 正确写法
typedef struct node_tag {
    int data;
    struct node_tag *next;
} node_t;

编译器在实际分配时会按照结构体成员列表的顺序一个接一个的分配内存，并且只有当存储成员需要满足正确的边界对齐要求时，成员之间可能会出现用于填充的额外内存空间。

```c
struct align {
    char a;
    int b;
    char c;
}

如果某个机器的整型值长度为 4 个字节，并且它的起始存储位置必须能够被 4 整除，那么这个结构在内存中的存储将是下面这种形式



a



b
b
b
b
c






我们可以通过改变成员列表的声明顺序，让那些对边界要求严格的成员首先出现，对边界要求弱的成员最后出现，这样可以减少因为边界对齐而带来的空间损失。
struct align {
    int b;
    char a;
    char c;
}




b
b
b
b
a
c



当程序创建几百个甚至几千个结构时，减少内存浪费的要求就比程序的可读性更为急迫。我们可以使用sizeof操作符来得出一个结构的整体长度。如果必须要确定结构某个成员的实际位置，则可以使用offsetof(type, member)宏，例如：
offset(struct align, b);

一句话
标识符：标识符就是变量、函数、类型等的名字，标识符的长度没有限制，但是 ANSI 标准允许编译器忽略第 31 个字符以后的字符，并且允许编译器对用于表示外部名字（由链接器操作的名字）的标识符进行限制，只识别前 6 位不区分大小写的字符。
注释：代码中所有的注释都会被预处理器拿掉，取而代之的是一个空格。因此，注释可以出现在任何空格可以出现的地方。
类型：C 语言中仅有 4 种基本数据类型，即整型、浮点型、指针和聚合类型（数组、结构等），所有其它的类型都是从这 4 中基本类型的某种组合派生而来。
类型长度：标准只规定了short int至少是 16 位，long int至少是 32 位，至于缺省的int是多少位则直接由编译器设计者决定。并且标准也没有规定这 2 个值必须不一样。如果某种机器的环境字长是 32 位，而且也没有什么指令能够更有效的处理更短的整型值，那它很可能把这 3 个整型值都设定为 32 位。
位域：基于 int 位域被当作有符号还是无符号数、位域成员的内存是从左向右还是从右向左分配、运行在 32 位整数的位域声明可能在 16 位机器无法运行等原因，注重可移植性的程序应该避免使用位域。
结构与指针：什么时候应该向函数传递一个结构而不是一个指向结构的指针呢？很少有这种情况。只有当一个结构特别小（长度和指针相同或更小）时，结构传递方案的效率才不会输给指针传递方案。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/cCUDwnJ69/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/ghceoN-RR/">
                        为什么宏定义要使用 do {...} while (0) ?
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2022-09-15</time>
                    
                        <a href="https://www.guanngxu.com/vnEfA3xxL/" class="post-tag i-tag
                            i-tag-error">
            #嵌入式
        </a>
                        
                        <a href="https://www.guanngxu.com/umBdDP7Ll/" class="post-tag i-tag
                            i-tag-banana">
            #C
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/ghceoN-RR/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/ghceoN-RR.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容:
do {…} while (0) in macros
do {...} while (0) 在宏定义中的作用
do{}while(0)只执行一次无意义？你可能真的没理解

近期参与的项目属于嵌入式软件领域，自然而然就得用 C 语言进行开发，开发过程中发现引入的第三方库里面有一些奇奇怪怪的写法，比如大佬们都喜欢使用do {...} while(0)的宏定义，在 Stack Overflow 上也有人提出了这个问题。之前从事 Linux 内核开发的谷歌大佬 Robert Love 给出了如下的解释：

do {…} while(0) is the only construct in C that lets you define macros that always work the same way, so that a semicolon after your macro always has the same effect, regardless of how the macro is used (with particularly emphasis on the issue of nesting the macro in an if without curly-brackets).
do {...} while(0) 在 C 中是唯一的构造程序，让你定义的宏总是以相同的方式工作，这样不管怎么使用宏（尤其在没有用大括号包围调用宏的语句），宏后面的分号也是相同的效果。

这句话读起来有些拗口，只觉得大佬的表述曲高和寡，翻译翻译就是：使用do {...} while(0)构造后的宏定义不会受到大括号、分号等影响，总能按照我们期望的方式调用运行。下面我们举几个实际的例子来加深理解。
// 现有如下宏定义
#define foo(x) bar(x); baz(x)

// 1. 可以这样调用
foo(wolf);

// 上述调用将会被展开为下列代码，完美没有问题
bar(wolf); baz(wolf);


// 2. 如果我们像下面这样调用呢？
if (!feral)
    foo(wolf);

// 上述调用将会被展开为下列代码，很明显这是错误的，并且是很容易犯的错误
if (!feral)
    bar(wolf);
baz(wolf);

为了避免上面例子所出现的问题，我们可以考虑使用{ }直接把整个宏包裹起来，如下所示：
// 修改宏定义为
#define foo(x) { bar(x); baz(x) }

// 3. 例 1 调用
if (!feral)
    foo(wolf);

// 现在上述调用将展开为下列代码
if (!feral) {
    bar(wolf);
    baz(wolf);
};


// 4. 我们再考虑一下如下调用呢
if (!feral)
    foo(wolf);
else
    bin(wolf);

// 上述调用将会被展开为下列代码，很明显又出现了语法错误
if (!feral) {
    bar(wolf);
    baz(wolf);
};
else
    bin(wolf);

我们继续考虑比使用{ }直接把整个宏包裹起来更好的方法，即本文标题所说的使用do {...} while (0)，即上述宏将定义为如下形式。
// 终极版宏定义
#define foo(x) do { bar(x); baz(x) } while (0)

// 5. 例 4 调用
if (!feral)
    foo(wolf);
else
    bin(wolf);

// 现在上述调用将展开为下列形式，很完美
if (!feral)
    do { bar(wolf); baz(wolf) } while (0);
else
    bin(wolf);

do {...} while (0)除了在宏定义中可以发挥完美的作用外，在某些情况下还可以当作goto使用。因为goto不符合软件工程的结构化，并且容易使得代码晦涩难懂，所以很多公司都不倡导使用甚至禁止使用。那么我们可以使用do {...} while (0)来做同样的事情。
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
int main()
{
   char *str;
   /* 最初的内存分配 */
   str = (char *) malloc(15);
   if(str != NULL)
     goto loop;
   printf(&amp;quot;hello world\n&amp;quot;);
loop:
   printf(&amp;quot;malloc success\n&amp;quot;);
   return 0;
}

上述代码我们可以修改为下列形式，使用do {...} while (0)将函数主体包裹起来，而break语句则替代了goto语句的作用，并且代码的可读性与可维护性都比上述goto方式更好。
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
int main()
{
  do{
      char *str;
      /* 最初的内存分配 */
      str = (char *) malloc(15);
      if(str != NULL)
       break;
      printf(&amp;quot;hello world\n&amp;quot;);
  }while(0);
   printf(&amp;quot;malloc success\n&amp;quot;);
   return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/ghceoN-RR/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                

                <!-- 金山词霸 -->
                <!-- <script>
                    const date = new Date();
                    const today = date.toISOString().substring(0, 10);
                    console.info(today)
                    $.ajax({
                        url: `http://sentence.iciba.com/index.php?c=dailysentence&m=getdetail&title=${today}`,
                        type: "GET",
                        dataType: "jsonp", //指定服务器返回的数据类型
                        success: function (data) {
                            $(".null-feature-image").css("background-image", `url(${data.picture2})`);
                            console.log(data);
                        }
                    });
                </script> -->
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar">
            <img src="https://www.guanngxu.com/images/avatar.png?v=1769266443907">
        </div>
        <h1 class="id_card-title">
            Guanngxu
        </h1>
        <h2 class="id_card-description">
            Keep trying
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                <a href="https://github.com/Guanngxu" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-github"></i></a>
                
                    <!-- twitter -->
                    
                        <a href="https://twitter.com/guanngxu" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-twitter"></i></a>
                        
                            <!-- weibo -->
                            
                                <a href="https://weibo.com/u/5288280194" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-weibo"></i></a>
                                
                                    <!-- facebook -->
                                    
                                        <!-- douban -->
                                        
                                            <a href="https://www.douban.com/people/Guanngxu" target="_blank" rel="noopener noreferrer">
                                                <svg t="1660751300927" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2563" width="200" height="200"><path d="M1023.979 862.827A161.152 161.152 0 0 1 862.805 1024H161.173A161.152 161.152 0 0 1 0 862.827V161.195A161.195 161.195 0 0 1 161.173 0.02h701.632a161.195 161.195 0 0 1 161.174 161.174v701.632z" fill="#515151" p-id="2564" data-spm-anchor-id="a313x.7781069.0.i2" class="selected"></path><path d="M218.56 208.064h586.816v66.09H218.56z m535.83 393.493v-258.41h-484.8v258.41h484.8zM339.882 409.173H684.8v126.358H339.883V409.173z m309.61 341.334c21.099-32.299 41.003-69.739 59.435-112.256l-70.507-25.707c-18.346 50.368-39.701 96.427-64 137.941H451.712c-20.373-53.802-43.328-99.818-69.077-137.941l-64.854 25.707c26.752 40.128 48.32 77.482 64.854 112.256H201.94v65.386h620.054v-65.386H649.493z" fill="#FFFFFF" p-id="2565" data-spm-anchor-id="a313x.7781069.0.i3" class=""></path></svg>
                                            </a>
                                        

        </div>
    </div>
    
    <script>
        // const date = new Date();
        // const today = date.toISOString().substring(0, 10);
        // console.info(today)
        // $.ajax({
        //     url: `http://sentence.iciba.com/index.php?c=dailysentence&m=getdetail&title=${today}`,
        //     type: "GET",
        //     dataType: "jsonp", //指定服务器返回的数据类型
        //     success: function (data) {
        //         $(".id_card-description").text(data.content)
        //         console.log(data);
        //     }
        // });
    </script>

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  <a href="https://beian.miit.gov.cn" target="_blank">蜀ICP备2022021904号</a> | 
  <a class="rss" href="https://www.guanngxu.com/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>