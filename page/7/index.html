<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    Guanngxu
</title>
<link rel="shortcut icon" href="https://www.guanngxu.com/favicon.ico?v=1751462361215">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://www.guanngxu.com/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://www.guanngxu.com/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>
<script async src="https://analytics.eu.umami.is/script.js" data-website-id="d80638ca-7f47-4227-af1c-714b9739ba9d"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://www.guanngxu.com">
                <img class="avatar" src="https://www.guanngxu.com/images/avatar.png?v=1751462361215" alt="">
            </a>
            <a href="https://www.guanngxu.com">
                <div class="site-title">
                    <h1>
                        Guanngxu
                    </h1>
                </div>
            </a>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                        <li>
                            <a href="/about" class="menu" target="_blank">
                                关于
                            </a>
                        </li>
                        
                                
                    
                            <li>
                                <a href="https://guanngxu.com/uAv93EeJY" class="menu">
                                    工具
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/bOFRz9RDX/">
                        深入理解 JavaScript——变量提升与作用域
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-08-06</time>
                    
                        <a href="https://www.guanngxu.com/6ys69eBdL/" class="post-tag i-tag
                            i-tag-success">
            #前端
        </a>
                        
                        <a href="https://www.guanngxu.com/ovndYzDa7N/" class="post-tag i-tag
                            i-tag-primary">
            #JavaScript
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/bOFRz9RDX/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/bOFRz9RDX.png) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
lhs rhs是啥意思
《Javasript 高级程序设计（第三版）》
《你不知道的 JavaScript（上卷）》

几乎所有的编程语言都能够存储变量当中的值，并且可以在之后对该值进行访问或修改。很明显需要一套良好的规则来存储这些变量，并且之后可以方便的找到这些变量，这套规则我们称之为作用域。
编译原理
我们一般把 js 归为「动态」或「解释执行」语言，但是它也会经历编译阶段，不过它不像传统语言那样是提前编译的，它的编译发生在代码执行前的几微秒内。
传统语言在执行之前会经历三个步骤：分词/词法分析、解析/语法分析、代码生成，关于这三个步骤的具体工作，可以查看编译原理相关的文献，我们可以把这三个步骤统称为编译。不过 js 引擎要复杂的多，它会在编译的时候对代码进行性能优化，尽管给 js 引擎优化的时间非常少，但是它用尽了各种办法来保证性能最佳。
我们需要先了解三个名词。引擎：从头到尾负责整个 js 程序的编译及执行过程；编译器：负责词法分析及代码生成；作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
var a = 2;，我们以这段程序为例，它首先声明了变量a，然后将2赋值给变量a。前一个阶段在编译器处理，后一个阶段由 js 引擎处理。
变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。
变量提升
用过 js 的人都知道 js 存在变量提升，那么它到底是如何提升的呢？我们看下面的一段代码
console.log(a);
var a = 2;

上述代码在a声明之前访问了变量a，按我们的逻辑它应该会抛出 ReferenceError 异常；或是变量提升直接输出 2。但是这两种答案都不对，输出的是undefined。
回顾一下前文的关于编译的内容，引擎会在解释 js 代码之前对其进行编译，编译阶段的一个重要工作就是找到所有的声明，并用合适的作用域将它们关联起来，包括变量和函数在内的所有声明都会在任何代码被执行之前首先被处理。所以我们前面列出来的代码实际上会变成下面这个样子。
var a;
console.log(a);
a = 2;

这个过程就好像变量和函数声明会从它们的代码中出现的位置被移动到最上面一样，这个过程就是提升。但是需要注意的是，函数声明会首先被提升，然后才是变量提升。
foo(); // 1
var foo;

function foo() {
    console.info(1);
}

foo = function() {
    console.info(2);
}

这段代码输出 1 而不是 2 ，它会被引擎理解为下面的形式。
function foo() {
    console.log(1);
}

foo(); // 1

foo = function() {
    console.log(2);
};

可以看到，虽然var foo出现在function foo()之前，但是它是重复的声明，因此会被忽略掉，因为函数函数声明会提升到普通变量前。所以在在同一个作用域中进行重复定义是一个很糟糕的做法，经常会导致各种奇怪的问题。
LHS 和 RHS 查询
LHS 和 RHS 是数学领域内的概念，意为等式左边和等式右边的意思，在我们现在的场景下就是赋值操作符的左侧和右侧。当变量出现在赋值操作符的左边时，就进行 LHS 查询；反之进行 RHS 查询。
RHS 查询与简单的查找某个变量的值没什么区别，它的意思是取得某某的值。而 LHS 查询则是试图找到变量容器的本身，从而可以对其进行赋值。
console.info(a);我们深入研究一下这句代码。这里对a的引用是 RHS 引用，因为这里a并没有赋予任何值，相应的需要查找并取得a的值，这样才能传递给console.info()。
a = 2;对a的引用则是一个 LHS 引用，因为实际上我们并关心a当前的值是什么，只是想为= 2这个赋值操作找到一个目标。
function foo(a) {
    console.info(a);
}
foo(2);

为了加深印象，我们再来分析一下上述代码中的 RHS 和 LHS 引用。最后一行foo()函数的调用需要对foo进行 RHS 引用。这里有一个很容易被忽略的细节，2 被当作参数传递给foo()函数时，2 会被分配给参数a，为了给参数a（隐式地）分配值，需要进行一次 LHS 查询，也就是说代码中隐含了a = 2的语句。
前文已经说过了console.info(a);会对a进行一次 RHS 查询，需要注意的是console.info()本身也需要一个引用才能执行，因此会对console对象进行 RHS 查询，并检查得到的值中是否有一个log方法。
为什么区分 LHS 和 RHS
我们考虑下面的一段代码，就可以为什么要区分 LHS 和 RHS 查询了，而且区分它们是分厂有必要的。
function foo(a) {
    console.info(a + b);
    b = a;
}
foo(2);

第一次对b进行 RHS 查询时是无法找到该变量的，这是一个未声明的变量，在任何相关的作用域中都无法找到它。如果 RHS 查询在所有嵌套作用域中都找不到该变量，引擎就会抛出 ReferenceError 异常。
引擎在执行 LHS 查询时，如果在全局作用域中也无法找到目标变量，全局作用域就会创建一个具有该名称的变量，并将其返还给引擎。

需要注意的是，在严格模式下是禁止自动或隐式地创建全局变量的，因此在严格模式中 LHS 查询失败时，引擎同样会抛出 ReferenceError 异常。

接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个值进行不合理的操作，比如对一个非函数类型的值进行函数调用，那么引擎就会抛出另一种叫做 TypeError 的异常。
作用域链
执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中，在 Web 浏览器中，全局执行环境被认为是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。
每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境，这个函数调用的压栈出栈是一样的。
当代码在环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终都是当前执行的代码所在环境的变量对象，说的比较抽象，我们可以看下面的示例。
var color = &amp;quot;blue&amp;quot;;

function changeColor() {
    var anotherColor = &amp;quot;red&amp;quot;;

    function swapColors() {
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        // 这里可以访问 color、anotherColor 和 tempColor
    }
    // 这里可以访问 color 和 anotherColor，但不能访问 tempColor
    swapColors();
}
// 这里只能访问 color
changeColor();

下面的图形象的展示了上述代码的作用域链，内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。函数参数也被当做变量来对待，因此其访问规则与执行环境中的其它变量相同。
window
  |-----color
  |-----changeColor()
            |----------anotherColor
            |----------swapColors()
                           |----------tempColor

作用域链还用于查询标识符，当某个环境中为了读取或写入而引入一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符，如果在局部环境中找到了该标识符，搜索过程就停止，变量就绪；如果在局部环境没有找到这个标识符，则继续沿作用域链向上搜索，如下所示：
var color = &amp;quot;blue&amp;quot;;

function getColor() {
    var color = &amp;quot;red&amp;quot;;
    return color;
}

console.info(getColor()); // &amp;quot;red&amp;quot;

在getColor()中沿着作用域链在局部环境中已经找到了color，所以搜索就停止了，也就是说任何位于局部变量color的声明之后的代码，如果不使用window.color都无法访问全局color变量。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/bOFRz9RDX/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/1M5AYjF7f/">
                        JavaScript 性能优化——惰性载入函数
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-08-04</time>
                    
                        <a href="https://www.guanngxu.com/6ys69eBdL/" class="post-tag i-tag
                            i-tag-other_2">
            #前端
        </a>
                        
                        <a href="https://www.guanngxu.com/ovndYzDa7N/" class="post-tag i-tag
                            i-tag-primary">
            #JavaScript
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/1M5AYjF7f/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/1M5AYjF7f.png) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考资料：
《JavaScript 高级程序设计（第三版）》
JavaScript专题之惰性函数
深入理解javascript函数进阶之惰性函数

因为不同厂商的浏览器相互之间存在一些行为上的差异，很多 js 代码包含了大量的if语句，将执行引导到正确的分支代码中去，比如下面的例子。
function createXHR() {
    if (typeof XMLHttpRequest != &#39;undefined&#39;) {
        return new XMLHttpRequest();
    } else if (typeof ActiveXObject != &#39;undefined&#39;) {
        if (typeof arguments.callee.activeXString != &#39;string&#39;) {
            var versions = [&#39;MSXML2.XMLHttp.6.0&#39;, &#39;MSXML2.XMLHttp.3.0&#39;, &#39;MSXML2.XMLHttp&#39;];
            var i, len;
            for (i = 0, len = versions.length; i &amp;lt; len; i++) {
                try {
                    new ActiveXObject(versions[i]);
                    arguments.callee.activeXString = versions[i];
                } catch (e) {
                    // skip
                }
            }
        }
        return new ActiveXObject(arguments.callee.activeXString);
    } else {
        throw new Error(&#39;No XHR object available.&#39;);
    }
}

我们可以发现，在浏览器每次调用createXHR()的时候，它都要对浏览器所支持的能力仔细检查，但是很明显当第一次检查之后，我们就应该知道浏览器是否支持我们所需要的能力，因此除第一次之外的检查都是多余的。即使只有一个if语句也肯定要比没有if语句慢，所以if语句不必每次都执行，那么代码可以运行的更快一些，惰性载入就是用来解决这种问题的技巧。
函数重写
要理解惰性载入函数的原理，我们有必要先理解一下函数重写技术，由于一个函数可以返回另一个函数，因此可以在函数内部用新的函数来覆盖旧的函数。
function sayHi() {
    console.info(&#39;Hi&#39;);
    sayHi = function() {
        console.info(&#39;Hello&#39;);
    }
}

我们第一次调用sayHi()函数时，控制台会打印出Hi，全局变量sayHi被重新定义，被赋予了新的函数，从第二次开始之后的调用都会打印出Hello。惰性载入函数的本质就是函数重写，惰性载入的意思就是函数执行的分支只会发生一次。
惰性载入
我们来看一个例子（例子来源于冴羽所写的JavaScript专题之惰性函数）。现在需要写一个foo函数，这个函数返回首次调用时的Date对象，注意是首次。
方案一
var t;
function foo() {
    if (t) return t;
    t = new Date()
    return t;
}
// 此方案存在两个问题，一是污染了全局变量
// 二是每次调用都需要进行一次判断

方案二
var foo = (function() {
    var t;
    return function() {
        if (t) return t;
        t = new Date();
        return t;
    }
})();
// 使用闭包来避免污染全局变量，
// 但是还是没有解决每次调用都需要进行一次判断的问题

方案三
function foo() {
    if (foo.t) return foo.t;
    foo.t = new Date();
    return foo.t;
}
// 函数也是一种对象，利用这个特性也可以解决
// 和方案二一样，还差一个问题没有解决

方案四
var foo = function() {
    var t = new Date();
    foo = function() {
        return t;
    };
    return foo();
};
// 利用惰性载入技巧，即重写函数

惰性载入函数有两种实现方式，第一种是在函数被调用时再处理函数。在第一次调用的过程中，该函数会被覆盖为另外一种按合适方式执行的函数，这样任何对原函数的调用都不用再经过执行分支了。
第二种实现方式是在声明函数时就指定适当的函数。这样第一次调用时就不会损失性能了，而是在代码首次加载时会损失一点性能，即是利用闭包写一个自执行的函数。
改进 createXHR
有了上面的基础，我们就可以将createXHR()改进为下列形式，这样就不用每次调用都进行判断了。
// 第一种实现方式
function createXHR() {
    if (typeof XMLHttpRequest != &#39;undefined&#39;) {
        createXHR = function() {
            return new XMLHttpRequest();
        }
    } else if (typeof ActiveXObject != &#39;undefined&#39;) {
        createXHR = function() {
            if (typeof arguments.callee.activeXString != &#39;string&#39;) {
                var versions = [&#39;MSXML2.XMLHttp.6.0&#39;, &#39;MSXML2.XMLHttp.3.0&#39;, &#39;MSXML2.XMLHttp&#39;];
                var i, len;
                for (i = 0, len = versions.length; i &amp;lt; len; i++) {
                    try {
                        new ActiveXObject(versions[i]);
                        arguments.callee.activeXString = versions[i];
                    } catch (e) {
                        // skip
                    }
                }
            }
            return new ActiveXObject(arguments.callee.activeXString);
        };
    } else {
        createXHR = function() {
            throw new Error(&#39;No XHR object available.&#39;);
        }
    }
}

// 第二种实现方式
function createXHR() {
    if (typeof XMLHttpRequest != &#39;undefined&#39;) {
        return function() {
            return new XMLHttpRequest();
        }
    } else if (typeof ActiveXObject != &#39;undefined&#39;) {
        return function() {
            if (typeof arguments.callee.activeXString != &#39;string&#39;) {
                var versions = [&#39;MSXML2.XMLHttp.6.0&#39;, &#39;MSXML2.XMLHttp.3.0&#39;, &#39;MSXML2.XMLHttp&#39;];
                var i, len;
                for (i = 0, len = versions.length; i &amp;lt; len; i++) {
                    try {
                        new ActiveXObject(versions[i]);
                        arguments.callee.activeXString = versions[i];
                    } catch (e) {
                        // skip
                    }
                }
            }
            return new ActiveXObject(arguments.callee.activeXString);
        };
    } else {
        return function() {
            throw new Error(&#39;No XHR object available.&#39;);
        }
    }
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/1M5AYjF7f/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/sPxxvjVav/">
                        非设计师需要知道的四个设计原则
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-06-22</time>
                    
                        <a href="https://www.guanngxu.com/3pFNTYNB8/" class="post-tag i-tag
                            i-tag-primary">
            #翻译摘录
        </a>
                        
                        <a href="https://www.guanngxu.com/6ys69eBdL/" class="post-tag i-tag
                            i-tag-info">
            #前端
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/sPxxvjVav/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/sPxxvjVav.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
作者：Anna 4erepawko Mészáros，UI/UX 设计师。
关注作者： Medium、Twitter

这篇文章是写给无力邀请专业设计师的所有内容创作者的，以及设计师异常忙碌的团队的非设计师们。如果您按照这些简单的步骤进行操作，我保证您的设计会变得更好。
这些 Tips 来源于我对身边非设计朋友的多年观察，家人与同事在日常生活中也需要设计他们的东西。比如简历、作品集，Facebook 和 Instagram 上帖子要使用的图片，YouTube 视频的缩略图等。
所有这些人都向我寻求帮助与建议，希望能让他们的东西看起来更好。我坚信「授人以鱼不如授人以渔」，所以我试图提供更有价值的建议，以便他们在未来也能解决类似的问题。
随着时间的推移，我意识到我一直在给所有人提供相同的建议，虽然每次所使用的措辞不同，但我所有的建议都可以提炼为以下四个原则。
这些 Tips 会帮您创造出美丽动人的设计吗？答案是不会！它们只会帮您创造出色、清晰且易于理解的设计。是每个人都可以轻松理解和互动吗？那当然，所以不多说废话，下面我就向您逐一展示。
对比
确保所有元素之间有足够的对比度。为什么？因为那些略有差异但是又不够不同东西，创造了一种恐怖谷。人类的眼睛会排斥它们，对它们感到厌恶、难以理解。我们不希望它们出现在我们的设计中，难道不是吗？

恐怖谷理论，是一个关于人类对机器人和非人类物体的感觉的假设。如果一个非人类实体不够拟人，那么它身上的人类特征会很容易辨认；而当它足够拟人时，他身上的非人类特征则会变得很容易辨认。因此会在人类观察者眼中产生一种古怪的感觉，想想您看到病患者或者尸体时的感觉。

因此您设计的元素要么完全相同，要么具有显著差异。
您可以从下面四个方面来突出对比：
1、颜色：浅色上使用暗色，反之亦然
示例： 切勿在浅蓝色上使用浅灰色或浅粉红色等灰色组合，它们会造成阅读/互动上的极大困难。

2、大小：相邻元素要么大小完全相同，要么大小区别很大
示例： 不要将 32pt 和 36pt 的文本放在一起；18pt 和 36pt 放在一起会显得更加协调。

3、粗细：与大小一样，相邻元素的粗细要么完全相同，要么有明显的区别
示例： 不要将相同字体的粗体与黑体放在一起，因为它们看起来太相似了；将黑体与细体放在一起会显得很协调。

4、风格：不要将一个斜体类型放在另一个斜体类型旁边，或者在一个衬线字体旁边放置另一个衬线字体。应该组合不同的东西。
示例： 不要将 Times New Roman 与 Georgia 放在一起，它们看起来太相似了，应该组合完全不同的风格。

一致性
确保相似的元素以相似的方式出现。为什么呢？首先，通过确保确保事物一致性，您可以让用户将注意力集中在设计的重要方面，而不是被随时变化的元素分散注意力。
其次，一致性也增加了用户对您的信任，使事物看起来实际上是设计的，而不是简单快速拼凑出来的。
一旦你选择了具体的风格，就要毫不犹豫的坚持下去，这里所说的风格包括字体、颜色、阴影、栅格、对齐、装饰风格等等。

当您处理许多相邻的不同部分时（比如 YouTube 的视频缩略图或是中型文章的封面），您应该为所有部分选择一种整体风格，并坚持使用。
奥卡姆剃刀 减少视觉噪音
在您的设计中，使用的元素越少越好。为什么呢？因为人类的大脑很难在输入过载的情况下处理信息并作出决策。您应该使用尽可能少的装饰元素（字体、颜色、阴影、图标等等）。
将奥卡姆剃刀应用于所有内容。如果只需要两个元素就能满足需求，那么就不要使用 3 个元素；如果 10 个元素实现所需的功能，那么就不要用 20 个元素。

如果您不喜欢古老的英国哲学家风格，更喜欢您在 Netflix（一家美国流媒体提供商）上看到的东西。请将怦然心动的人生整理魔法应用到您的设计中。

《怦然心动的人生整理魔法》是美国流媒体提供商Netflix于2019年1月1日首播的一档真人实境秀节目。节目由日本“整理咨询顾问” 近藤麻理惠主创。她在每集节目中拜访一个家庭，帮助他们整理自己的房间。
近藤麻理惠认为整理房间时应当将物品分为五类：衣物、书籍、纸张文件、杂物和情感纪念品；在整理时拿起每件物品，如果能使自己“怦然心动”则留下，如果不能则要感谢物品的贡献然后与其告别。

间距
元素的位置会发送关于其含义的元级别消息。为什么这很重要？因为了解如何放置元素以及在它们周围预留了多少空间有助于降低设计的复杂性，因此会使人更加愉悦，并且更容易交互。
在您的设计中使用间距来传达下面 3 个方面的信息：
1、接近度 = 相关性
与其它元素相比，彼此更接近的事物被认为它们有更强的相关性。这是最重要的，因为我觉得它常常容易被忽视。
它可以以很多不同的方式应用，比如行与行之间应该有一定的间距，而不是一行中每个单词之间的间距那么小；同样不同段落之间的空间也比段落内的行空间要大。

元素之间的间距应该小于元素与组合边缘之间的间距。

标签和支撑信息应该位于其相关元素附近。

2、留白
结合奥卡姆剃刀，给您的设计尽可能留白，去整理它们，使它们的意义更加明显。
如果把太多元素放在有限的空间里，就像同时听三首不同的哥，很难理解别人在说什么。

3、重要性与顺序
这是一个很普通的常识，但是我还是要在这里提到它。
最重要的事情放在第一位，使它们占据最大的空间，用一系列的事物来传达秩序。
结束语
恭喜您！如果您按照这些 Tips 进行设计，那么按照行业标准，它可能看起来非常好。
For everything else, there is always a designer.

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/sPxxvjVav/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/4jVVEgoF6/">
                        深入理解计算机系统——CPU 是怎样工作的？
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-04-27</time>
                    
                        <a href="https://www.guanngxu.com/mZ_iBKmVWo/" class="post-tag i-tag
                            i-tag-info">
            #操作系统
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/4jVVEgoF6/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/4jVVEgoF6.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
处理器是如何工作的
《编码：隐匿在计算机软硬件背后的语言》——[美] Charles Petzold

CPU 大家应该都不会陌生，日常用的手机、电脑中都有 CPU，CPU 作为一个设备的大脑，指挥着其它各种硬件的协同工作，芯片技术也是国内一直没有突破的技术。
我们先来看看怎么让电路去运算呢？比如如何让电路运算1 + 1，直接使用下面这个装置就可以了。

作为一个比较好奇的人，总会想看看那个方框框里面是什么样子的，让我们慢慢解开加法器的外衣。

这个电路你应该不会陌生，它需要两个开关都闭合时灯泡才会发光，也就是说它有两个输入，开关闭合时我们认为输入为 1，未闭合状态视为 0；而灯泡是否发光就是我们的输出，发光为 1，否则为 0。于是就有了下面这张表。



and
0
1




0
0
0


1
0
1



这样的电路我们就把它称之为与(and)门，它接受两个逻辑输入，并会给出我们一个逻辑输出，与它相似的电路还有逻辑或(or)、**异或(xor)**等等，因为太多了，就不一一介绍了，如果感兴趣可以 Google 一下。
为了方便我们把上面的电路做一个简化，抽象成下面这个样子，其它的电路也可以通过 Google 找到它们的样子。

现在直接给出一个可以运算加法的电路，它的样子长下面这样。

我们也可以给它列一个表，显得更清晰，表中之所以有两位是因为加法有可能会产生进位，而我们使用的是二进制表示，所以10表示的是十进制中的2。



+
0
1




0
00
01


1
01
10



有加法就很好办了，减法实际上是加一个负数，除法可以改写成乘法，乘法又可以改写成加法，现在加法一统天下了。
好了，上面说了那么多，还贴了那么多图，只是为了让你相信电路是可以实现我们数学上的运算的，下面就没有那么声情并茂了。
我们可以把一个运算抽象为下面这个模型。
输入数据 --&amp;gt; 运算 --&amp;gt; 输出数据

计算机中把各种像上述加法器一样的运算器放在了同一个小盒子里面，组成成一个运算器集合，我们给它取个名字叫算术逻辑单元（ALU：Arithmetic Logical Unit），它是 CPU 的核心组成部分。
当然我们不可能只进行加法这种简单运算，一个很长很长的算式需要经过多步运算，小学我们就学过梯等式，它实际上有一大推输入，中间那么多梯子，都是临时步骤，临时步骤、数据一类的东西都需要有个东西给它存起来，所以在 CPU 就拿出一个小盒子当做存储器。
# 梯等式
485 - ( 6 × 4 + 32 )
= 485 - ( 24 + 32 )
= 485 - 56
= 429

现在我们有了存储器和运算器两个干事的人，但是没有一个统筹兼顾的领导者，控制器就充当了这个角色，它需要把控制储存器中的数据发送到 ALU 去进行运算，然后再将运算的结果取出来存到储存器中。总的来说，控制器的工作就是完成协调和指挥整个计算机系统的操作。
我们把上面的结构画出来，图中的虚线表示指令流，实线表示数据流，这个结构就是著名的冯 · 诺依曼体系结构，遵循这种结构的计算机都叫做冯诺依曼机，现在所有的机器都是冯诺依曼机。

请注意，我们现在实际上只有硬件，没有软件是什么事情都干不了了，我们这里所说的软件是一堆指令序列，比如加法指令、传送指令等等组成的序列，也就是我们常说的汇编语言。
但是在早期并不是这样的，这台机器上编写的指令序列是无法运行在另一家公司生产的机器上的，即使是同一个公司的机器，如果不是同一代，那也不能运行，所以早期的编程是直接面向硬件的。
这时就有人站出来研究如何实现一次编写多处运行了，IBM 首次在它的 360 系统上引入了ISA的概念，即指令集体系结构。
指令集体系结构将编程所要了解的硬件信息从硬件系统中抽象了出来，这样开发人员就可以直接面向处理器的 ISA 进行编程了。
为什么手机上的软件不能运行在电脑中呢？就是因为个人电脑所使用的 Intel 和 AMD 处理器都是基于 x86 指令集的，而手机大多数都使用的是基于 ARM 指令集的处理器。
现在处理器被分为指令集体系结构、处理器微架构、处理器物理实现三个层次。体系结构相当于需求，微架构好比设计，物理实现则是具体的实现过程。
比如我们规定指令集中必须有加法指令，这个指令你怎么设计、如何实现是你给的事，我只管给出两个加数你能给我输出一个正确的结果，简单来说就是抽象封装。


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/4jVVEgoF6/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/S9me2CdAH/">
                        如何保证快速加载网页？——详解浏览器缓存机制
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-04-23</time>
                    
                        <a href="https://www.guanngxu.com/6ys69eBdL/" class="post-tag i-tag
                            i-tag-banana">
            #前端
        </a>
                        
                        <a href="https://www.guanngxu.com/sQhfLtj4g/" class="post-tag i-tag
                            i-tag-success">
            #计算机网络
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/S9me2CdAH/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/S9me2CdAH.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考内容：
彻底理解浏览器的缓存机制
彻底弄懂HTTP缓存机制及原理

前端开发人员有大部分时间都在调整页面样式，如果页面没有按照自己预期的样式显示，可能想到的第一个解决方案就是清一下浏览器缓存，HTTP 缓存机制作为 Web 性能优化的重要手段，也应该是 Web 开发人员必备的基础知识。我们常说的浏览器缓存机制也就是 HTTP 缓存机制，它是根据 HTTP 报文的缓存标识运行的，所以首先要对 HTTP 报文有一个简单的了解。
HTTP 报文
HTTP 报文是浏览器和服务器间进行通信时所发的响应数据，所以 HTTP 报文分为请求（Request）报文和响应（Response）报文两种，浏览器向服务器发送的是请求报文，而服务器向浏览器发送的是响应报文。HTTP 请求报文由请求行、请求头、请求体组成，响应报文则由状态行、响应头、响应正文组成，与缓存有关的规则信息则都包含在请求头和响应头中。
缓存概述
浏览器与服务器通过请求响应模式来通信，当浏览器第一次向服务器发送请求并拿到结果后，会根据响应报文中的缓存规则来决定是否缓存结果，其简单的流程如下图：

浏览器每次发起请求都会先在浏览器缓存中查找该请求的结果和缓存标识，而且每次拿到响应数据后都会将该结果和缓存标识存入缓存中。HTTP 缓存的规则有多种，我们可以根据是否需要重新向服务器发起请求这一维度来分类，即有强制缓存和协商缓存两类，也有人把协商缓存叫对比缓存。
强制缓存
我们先自己想一下，使用缓存是不是会有下面几种情况出现。


存在所需缓存并且未失效：直接走本地缓存即可；强制缓存生效；


存在所需缓存但已失效：本地缓存失效，携带着缓存标识发起 HTTP 请求；强制缓存失效，使用协商缓存；


不存在所需缓存：直接向服务器发起 HTTP 请求；强制缓存失效。


控制强制缓存的字段分别是Expires和Cache-Control，并且Cache-Control的优先级高于Expires。
Expires
Expires是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回的该缓存到期时间，即下一次请求时，请求时间小于Expires值，就直接使用缓存数据。到了 HTTP/1.1，Expires已经被Cache-Control替代了。
Expires被替代的原因是因为服务端和客户端的时间可能有误差（比如时区不同或者客户端与服务端有一方时间不准确），这就会导致缓存命中误差，强制缓存就变得毫无意义。
Cache-Control
Cache-Control是 HTTP/1.1 中最重要的规则，主要取值为：



取值
规则




public
所有内容都可以被缓存，包括客户端和代理服务器，纯前端可认为与private一样。


private
所有内容只有客户端可以缓存，Cache-Control的默认值。


no-cache
客户端可以缓存，但是是否缓存需要与服务器协商决定（协商缓存）


no-store
所有内容都不会被缓存，既不是用强制缓存，也不使用协商缓存，为了速度快，实际上缓存越多越好，所以这个慎用


max-age=xxx
缓存内容将在 xxx 秒后失效



我们可以看看下面这个例子，可以从截图中看到Expires是一个绝对值，而Cache-Control是一个相对值，此处为max-age=3600，即 1 小时后失效。在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于Expires是更好的选择，所以同时存在时只有Cache-Control生效。

协商缓存
协商缓存，顾名思义就是需要双方通过协商来判断是否可以使用缓存。强制缓存失效后，浏览器带着缓存标识向服务器发起请求，由服务器根据缓存标识决定是否可以使用缓存，那自然而然就有协商缓存生效和协商缓存不生效两种情况了。

上图是协商缓存生效的流程，如果协商缓存不生效则返回的状态码为 200。协商缓存的标识也是在响应报文的响应头中返回给浏览器的，控制协商缓存的字段有Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高，所以同时存在时只有Etag / If-None-Match生效。
Last-Modified / If-Modified-Since
你可以往上翻一翻，看一下那张响应报文截图，其中有一个Last-Modified字段，它的值是该资源文件在服务器最后被修改的时间。
If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值。服务器收到该请求后，发现该请求头有If-Modified-Since字段，则会将If-Modified-Since与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件。

Etag / If-None-Match
Etag是服务器响应请求时，返回当前资源文件的一个由服务器生成的唯一标识。
If-None-Match则是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，如果一致则就返回 304，代表资源无更新，可以继续使用缓存文件；否则重新返回资源文件，状态码为200，

disk cache 与 memory cache
我们可以通过浏览器调试工具查看强制缓存是否生效，如下图所示，状态码为灰色的请求就代表使用了强制缓存，请求对应的 size 显示了该缓存存放的位置，那么什么时候用 disk 什么时候用 memory 呢？

猜都能猜出来，肯定是优先使用内存（memory）中的缓存，然后才用硬盘（disk）中的缓存。
内存缓存具有快速读取的特点，它会将编译解析后的文件直接存入该进程的内存中，但是一旦进程关闭了，该进程的内存就会被清空，所以如果你将一个网页关闭后再打开，那么缓存都会走硬盘缓存，而如果你只是刷新网页，那有部分缓存走的就是内存缓存。
浏览器一般会再 js 和图片等文件解析执行后直接存入内存缓存中，当刷新页面时，这部分文件只需要从内存缓存中读取即可，而 css 文件则会存入硬盘中，所以每次渲染页面都需要从硬盘中读取文件。
总结
到这里偷懒一下子了，找到人家画的一张图，看图就行了。


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/S9me2CdAH/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/_PaEG890x/">
                        什么是契约测试？
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-04-10</time>
                    
                        <a href="https://www.guanngxu.com/9WeHlVlqK9/" class="post-tag i-tag
                            i-tag-banana">
            #软件测试
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/_PaEG890x/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/_PaEG890x.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
参考文章：
聊一聊契约测试 —— ThoughtWorks洞见
契约测试
前后端分离了，然后呢？

契约测试全称为：消费者驱动契约测试，最早由 Martin Fowler 提出。契约这个词从字面上很容易理解，就是双方（多方）达成的共同协议，那又为什么需要契约测试这个东西呢？
在当前微服务大行其道的行业背景下，越来越多的团队采用了前后端分离和微服务架构，我们知道微服务是由单一程序构成的小服务，与其它服务使用 HTTP API 进行通讯，服务可以采用不同的编程语言与数据库，微服务解决了单体应用团队协作开发成本高、系统高可用性差等等问题。
但是微服务也引入了新的问题，假设 A 团队开发某服务并提供对应的 API，B 团队也在开发另一个服务，但是他们需要调用 A 团队的 API，为了产品的尽快发布，两个团队都争分夺秒，已经进入联调阶段了，然而出现了下面这样的尴尬情况。

随着越来越多的微服务加入，它们的调用关系开始变得越来越复杂，如果每次更改都需要和所有调用该 API 的团队协商，那沟通成本也未免太大了，试想下图的沟通成本。

为了保证 API 调用的准确性，我们会对外部系统的 API 进行测试，如果外部系统稳定性很差，或者请求时间很长的时候，就会导致我们的测试效率很低，当调用 API 失败时，你甚至无法确定是因为 API 被更改而导致的失败还是运行环境不稳定导致的失败。
A 团队提供的 API 不稳定，肯定会导致 B 团队效率低下，为了不影响 B 团队的进度，所以构建了测试替身，通过模拟外部 API 的响应行为来增强测试的稳定性和反应速度。

但是这样做真的就解决问题了吗？当所有内部测试都通过时，能拍着胸脯说真正的外部 API 就一定没有变化？很简单的一个解决方案就是：部分测试使用测试替身，另一部分测试定期使用真实的外部 API，这样既保证了测试的运行效率、调用端的准确性，又能确保当真实外部系统API改变时能得到反馈。

感觉剧情到这里就差不多该结束了，实际上真正的高潮部分开刚刚开始。如果外部 API 的反馈周期很长，那增加真实 API 测试间隔时间就又回到了最初的起点。现在我们回顾一下上面的方案。
在上面的场景中，我们都是已知外部 API 功能来编写相应的功能测试，并且使用直接调用外部 API 的方式来达到测试的目的，如此就不可避免的带来了两个问题：

API 调用者（消费者）对服务提供方（生产者）的更改是通过对 API 的测试来感知的；
直接依赖于真实 API 的测试效果受限于 API 的稳定性和反映速度。

解决方案首先是依赖关系解耦，去掉直接对外部 API 的依赖，而是内部和外部系统都依赖于一个双方共同认可的约定—“契约”，并且约定内容的变化会被及时感知；其次，将系统之间的集成测试，转换为由契约生成的单元测试，例如通过契约描述的内容，构建测试替身。这样，同时契约替代外部 API 成为信息变更的载体。
前后照应一下，我们现在再来看一下消费者驱动契约测试。它有两个不可或缺的角色：消费者是服务使用方；生产者（提供者）是服务提供方。采用需求驱动（消费者驱动）的思想。契约文件（比如 json 文件）由双方共同定义规范，一般由消费者生成，生产者根据这份契约去实现。
契约测试其中一个的典型应用场景是内外部系统之间的测试，另一个典型的例子是前后端分离后的 API 测试。行业内比较成熟的解决方案是 Swagger Specification 和 Pact Specification，这里不做展开讨论。
我们同样可以把契约测试的思想用到代码的编写中，契约测试通过一个契约文件来解耦依赖，那么对于需要用户定义很多规则的场景，我们同样可以将这些规则像契约文件一样抽取出来，这样就降低了代码之间的耦合度。
最后敲敲黑板，契约测试不是替代 E2E 测试的终结者，更不是单元测试的升级换代，它更偏向于服务和服务之间的 API 测试，通过解耦服务依赖关系和单元测试来加快测试的运行效率。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/_PaEG890x/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/h1zgmhimT/">
                        智齿｜读研否｜家庭小江湖｜广告乱象
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-02-07</time>
                    
                        <a href="https://www.guanngxu.com/u3bra3rlo/" class="post-tag i-tag
                            i-tag-other_1">
            #健康生活
        </a>
                        
                        <a href="https://www.guanngxu.com/Ykw3uqJED/" class="post-tag i-tag
                            i-tag-other_1">
            #随笔思考
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/h1zgmhimT/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/h1zgmhimT.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            建议读者大人们，如果自己经常一上火牙就疼，或者自己感觉牙已经有点问题了，可以提早预约医院的口腔科查一下，如果有问题早点预防，总是没有坏处的。抽烟的半年洗一次牙，不抽烟的一年洗一次牙。
因为智齿发炎被狠狠的折磨了近两周，我属于比较能忍得疼痛的人，这不周末才进行了一场春季骑行，唯有美景与美食不可辜负，什么病痛都是浮云，但回想起连续几晚上疼到睡不着觉的滋味，昨天毅然决然斩草除根，给拔掉了，今天就感觉好了很多。

前几天考研成绩出来了，估计现在大部分同学都在准备复试，我没有体验过考研的这个过程，毕业这半年有时候还是会想，我也应该体验一下考研的那个过程，已经很久没有体验过把所有时间都投入到一件事情上的快乐了。
但我还是不太建议读研，我这是无责任建议，毕竟自己没有读过研究生，在研究生实验室待了两年，算是有一半的硕士生经历吧。对于学历我一直以来的观点都是绝大部分人将它的作用放大了，总是认为名校成造就了强能力，而恰恰把因果关系给弄反了，是能力强的人都进了名校（本科）。当然，不否认像医学一类的专业是肯定要考研的，一棒子全打死肯定是不对的。

刘大发起的读书活动告一段落了，跟着小伙伴们泛泛的读了一遍《深入理解计算机系统》，只能用“痛并快乐着”来形容这个过程，每周输出一篇读书笔记，没有按时输出就罚钱的规矩很好，人还是需要自己逼自己才行。
这本书不适合初学者阅读，在豆瓣上的评分接近 10 分，不讲究速成，而是一本内功心法，如果是您是码农的话，读一读绝对会提高一个层级。现在已经开启了另一本书籍的阅读计划，刘大这个活动组织的超好。

春节回家发现了一个巨大的变化，我老家那种贫困县地区的村民们，也在开始讨论保险这一类产品了，我是觉得这个改变太大了，说明农民伯伯的经济水平也有很大的提升了。另外通过朋友圈还发现，我认识的大佬们貌似出身都并不是多好，反倒是大部分普通朋友家里的矿更多。
我们家族每年会组织祭祖活动，在正月初三一大家 50 人左右一同祭拜曾祖曾母，通过这么一个活动把整个大家族的年轻人联系起来，能搭建这样一个平台很棒，我正也在着手将家族信息数字化。

说到这里，想说一句家族群是个小江湖，亲戚之间也是暗暗较劲的，母亲不会抢群里几个特定的人发的红包，家里都是山路，车技不好的人很容易就寸步难行，一表叔就因为不到 10 米的距离，整个春节都在亲戚朋友面前抬不起头。
堂弟现在是民航飞行员在读，而另一个表弟今年正值高考，说要去考炮兵学院，将来好把飞机打下来，这一下可好了，这些话全部伯父被截屏保留了，将来某一天要是这俩兄弟闹矛盾了，估计有的好看。保二爷写的家族群不是群，是江湖...看起来更有趣一点。
在我身上更可悲的事情发生了，所有长辈一致认同应该由我来管理家族群，想想整个群里充斥的都是是那种要露不露、似露非露、就是不露的视频，或者是用粗糙都无法形容的大而泛的鸡汤文，整个头就大了，这可比解决技术问题难多了。

最近愈发觉得“大佬”之间的抄袭严重了，真大佬基本都是原创内容，或者是引用了别人的文字就标注出来，然而总是看到一些“大佬”原封不动发出来，还不表明出处，下面粉丝跟着继续做同样的事，我看到最多的一次是朋友圈连续 10 多条是一样的段子。

最后想无责任乱说一点科技相关的东西，5G 是当下的风口浪尖，各大厂商都希望在 5G 上有一席之地，搞芯片的搞芯片、做基站的做基站、整手机的整手机，5G + IPV6 肯定会带来无法想象的未来，5G 会大幅推动智能硬件的应用，但是手机这个应用场景是不是被夸大了呢？
现在的 4G 手机在线看一部高清电影不会有多卡顿的现象，广大吃瓜群众和各大媒体，一直都拿着 5G 手机来吹嘘，吃瓜群众跟随媒体引导的大流，我总觉得当拿到 5G 手机的那一刻，心里肯定会从喜悦急转失望的，就像目前的苹果产品一样。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/h1zgmhimT/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/M_3PVzDfm/">
                        Bootstrap-table 如何合并相同单元格
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-01-26</time>
                    
                        <a href="https://www.guanngxu.com/6ys69eBdL/" class="post-tag i-tag
                            i-tag-other_4">
            #前端
        </a>
                        
                        <a href="https://www.guanngxu.com/EWmAbJCJGF/" class="post-tag i-tag
                            i-tag-other_2">
            #TypeScript
        </a>
                        
                        <a href="https://www.guanngxu.com/ovndYzDa7N/" class="post-tag i-tag
                            i-tag-success">
            #JavaScript
        </a>
                        
                        <a href="https://www.guanngxu.com/krqSF7tYC/" class="post-tag i-tag
                            i-tag-banana">
            #算法
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/M_3PVzDfm/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/M_3PVzDfm.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            Bootstrap-table 官方提供了合并单元格方法 mergeCells，它根据四个参数可以合并任意个单元格，我们要做的只是告诉它怎么合并。
要合并同一列相同的单元格，无非两种办法，一种是一边遍历一边合并，遍历完了再合并。这里采用第二种办法，这里不需要遍历所有数据，因为用户只能看到当前页的数据，所以只遍历当前页的数据更省时间。
下面是我实现的获取合并信息算法，最终返回的是一个哈希表，比如下面的这个表格，如果要对「性别」这一列进行合并，很明显前面两个“男”需要合并成一个单元格，再去看下 Bootstrap-table 提供的 API，它需要的是从哪个单元格开始，合并多少个单元格，也就是它需要的是两个数值类型的参数。



姓名
性别
年龄




张三
男
23


李四
男
19


王二
女
20


麻子
男
21



所以我把哈希表设置为，键存的是索引，值存的是从这个索引开始后面连续有多少个和它一样的单元格，那么上述表格性别这一列所得到的合并信息哈希表就为：
{
    0: 2,
    2: 1,
    3: 1
}

下面算法很简单，使用两个指针遍历指定的列，如果两个指针所指向的数据相同，那么就将键所对应的值进行加一操作，整个方法只会对该列数据遍历一边，所以时间复杂度为 O(n)。
let getMergeMap = function (data, index: number) {
    let preMergeMap = {};
    // 第 0 项为表头，索引从 2 开始为了防止数组越界
    for (let i = 2; i &amp;lt; data.length; i++) {
        let preText = $(data[i-1]).find(&#39;td&#39;)[index].innerText;
        let curText = $(data[i]).find(&#39;td&#39;)[index].innerText;
        let key = i - 2;
        preMergeMap[key] = 1;
        while ((preText == curText) &amp;amp;&amp;amp; (i &amp;lt; data.length-1)) {
            preMergeMap[key] = parseInt(preMergeMap[key]) + 1;
            i++;
            preText = $(data[i - 1]).find(&#39;td&#39;)[index].innerText;
            curText = $(data[i]).find(&#39;td&#39;)[index].innerText;
        }
        // while循环跳出后，数组最后一项没有判断
        if (preText == curText) {
            preMergeMap[key] = parseInt(preMergeMap[key]) + 1;
        }
    }
    return preMergeMap;
}

上述算法得到了单列数据的合并信息，下一步就是按照这个信息进行相同单元格的合并了，因此封装了下面的方法按照指定哈希表进行合并。
let mergeCells = function (preMergeMap: Object, target, fieldName: string) {
    for (let prop in preMergeMap) {
        let count = preMergeMap[prop];
        target.bootstrapTable(&#39;mergeCells&#39;, { index: parseInt(prop), field: fieldName, rowspan: count });
    }
}

到目前为止，我们实现的都只是对单列数据进行合并，要实现对多列数据进行合并，那么只需要对所有列都进行相同的操作即可。
export let mergeCellsByFields = function (data: Object[], target, fields) {
    for (let i = 0; i &amp;lt; fields.length; i++) {
        let field = fields[i];
        // 保证 field 与 i 是相对应的
        let preMergeMap = getMergeMap(data, i);
        let table = target.bootstrapTable();
        mergeCells(preMergeMap, table, field);
    }
}

因为我在程序中做了一点处理，保证了fields中每个值得索引与对应表头的索引是一样的，因此不需要额外传入索引信息。简单来说就是我所实现的表格会根据fields的顺序，实现列之间的动态排序。你需要注意的是这一点很可能和你不一样。
到现在已经能够合并所有的列了，查看 Bootstrap-table 的配置信息发现，它有个属性是 onPostBody 它会在 table body 加载完成是触发，所以把这个属性配置成我们的合并单元格方法即可。
// groups 为要合并的哪些列
onPostBody: function () {
    mergeCellsByFields($(&#39;#table&#39; + &#39; tr&#39;), $(&#39;#table&#39;), groups);
}

再说一点不太相关的，我实现的是让用户可以自己选可以合并多少列，即用了一个可多选的下拉列表框供用户选择，根据用户选择的数量去合并，所以传入了一个groups参数。
最后推荐一个排序插件 thenBy，你可以用它进行多字段排序，比如用在合并相同单元格的场景，在绘制表格前先对数据进行排序，那么最后合并的结果就是把所有相同的数据聚合到一起了，并且还将它们合并到一起了，起到了一个隐形的过滤查询功能。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/M_3PVzDfm/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/Dj7VgGQ1S/">
                        坟头蹦迪｜清理手机上的干扰信息｜2018 简短总结
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-01-13</time>
                    
                        <a href="https://www.guanngxu.com/6ZjSGnvm9/" class="post-tag i-tag
                            i-tag-">
            #年度总结
        </a>
                        
                        <a href="https://www.guanngxu.com/Ykw3uqJED/" class="post-tag i-tag
                            i-tag-other_3">
            #随笔思考
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/Dj7VgGQ1S/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/Dj7VgGQ1S.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            前一周在一席上面看了一场演讲叫「不正经历史研究所所长」，整场演讲都伴随着欢声笑语，讲的是民间文化与经典文化，经典文化实际上是统治阶级强行推动的精致文化，绝大部分老百姓是看不懂这些东西的，反正我自己参观博物馆，如果没有讲解，我是完全看不懂那些玩意的。
能和生活联系在一起的文化最有活力，比如天天发杨超越祈求不挂科，拜拜马云希望有更多的钱等等。有一句老话叫「人活一口气」，民间文化都基于此，我在别人面前要抬得起头，要的是气派、要的是大气，上个世纪的「四大件」应该就是成功的一个标配，老百姓置办这些物件后，在邻居面前也更能昂首挺胸了。
昨天了解到一个朋友家乡的有一个非常奇怪的习俗，那就是「坟头蹦迪」，我最开始的想法是，这是不是最近兴起来的习俗，但是一问才知道，他小时候就是这样的了。基于我们的体系是无法理解坟头蹦迪的，你能说它们对于亲人的去世就不伤心吗？他们要的还是能抬起头，来参加追悼会的人们看到这么豪华的场面，第一反应是故人后代是很有成就的，在某种程度上这算是对故人的颂扬。

花了几个小时时间把微信清理了一下，只留下了 83 个公众号，这其中还包括一信用卡一类的服务号，也就是说只留下了 70 个左右的公众号。留下的都是小而美的公众号，这些大佬作者的更新频率也很低，比如子柳老师最近才更新了一篇文章，而上一篇文章的更新时间是 7 月 25 日。
最近在自己身上认识的一个问题是，关注的公众号太多读不过来，虽然在此之前已经筛选掉了很多号，然而自己还是读不过来，所以索性就做了减法。现在像公众号这些，已经变成了获取信息的一个重要渠道，我也确实比周围小伙伴掌握信息更快，大部分时间也自认为比他们更了解真相。
但是我最近突然有个疑问，我真的比他们更了解真相吗？大部分人是通过垃圾文章获取信息，我虽然没有跟着垃圾文章人云亦云，但是我还是通过网络获取信息的，那么我是不是看到的是另外一种看起来更接近真相的假象呢？
这些信息其实我就算不知道好像也没有什么大碍，顶多是别人谈什么新闻时，我所了解的也就他们知道的那么点而已，更好的方式是让自己的大脑去思考，以时间的维度去追踪事件的发展。
顺便推荐一个应用叫「刷屏」，我发现自己通过「刷屏」、「知识星球」、「微信公众号」、「朋友圈」四个地方，已经掌握大部分信息了，经常同事给我说某某新闻，而我在两三天前已经见过了。

我对国际计量大会修改「1 千克」的定义这件事印象很深，但是这件事我只看到在阮一峰老师的文章中有被提到过；人们更喜欢听自己了解的领域，跟自己同好的很容易产生好感，一些明星结婚、出轨竟然能把微博的服务给搞挂了，说明绝大部分人还是更喜欢撩自己 G 点的信息。

另外第二个问题是自己现在比在学校时更喜欢玩手机了，在学校时还能做到不带手机去自习，现在是隔一会儿就看看手机，把本来就碎片化的时间变得更加碎片化了，这种效率导致工作、学习效率低下，所以把微信和 TIM 的通知全部关掉了。

写到这里发现有点点像总结，索性就给自己简单总结总结吧。2018 我从校园走向了社会，完成了从学生到职场的转变。最大的改变是思维的提升，知道去投资自己，在学生时代，愿意花几百块钱去买课程，这对我来说是很大的突破，和现在愿意花几百的概念完全不一样，想想那时候一个月生活费总共也没有多少，而我去看了下自己在毕业前花在这方面的钱居然有一千多，如果加上毕业后的开销，那就是两千多了，真感谢那时候的自己。
这其中的收获是巨大的，后面我偶尔会向朋友推荐一些好的付费课程，但是他们都和大部分人一样，吃一顿饭花几百块钱，而如果花点钱买一堂课提升一下自己，就好像要他命一样，所以后面就不和他们讲了。

2018 开始用文字记录技术、生活、感悟，这其中的收获也是不小的，认识了此前只能仰望的大佬，结交了志同道合的朋友，而且也让自己更愿意去思考了。收到电子工业出版社的约稿合同，但是现在书都没写完，明年还写不完的话，那就不写了，主要是懒。
自负的缺点已经在渐渐改变了，更加懂得了谦虚。眼界不再局限于技术，很多东西我都会去了解，也结交了很多有趣的人，初入职场，好好学习与不同的人沟通。以后如果有能力，希望能给山区带去一点点教育资源。
2019 依旧坚持每周和同事或者校友打一次羽毛球，常去爬爬山，和有趣的朋友一起疯一疯；多读书，用豆瓣等工具去筛选好书，加大阅读量；常输出，输出是更高层次的输入；尝试去了解金融的逻辑；学习新的技术领域。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/Dj7VgGQ1S/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://www.guanngxu.com/s1Mfu1JcV/">
                        2018 年个人总结
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-01-01</time>
                    
                        <a href="https://www.guanngxu.com/6ZjSGnvm9/" class="post-tag i-tag
                            i-tag-other_1">
            #年度总结
        </a>
                        
                        <a href="https://www.guanngxu.com/Ykw3uqJED/" class="post-tag i-tag
                            i-tag-other_3">
            #随笔思考
        </a>
                        
                </div>
                <div class="post-article">
                    
                        <a href="https://www.guanngxu.com/s1Mfu1JcV/" class="post-feature-image" style="background-image:url(https://www.guanngxu.com/post-images/s1Mfu1JcV.jpeg) ">
                        </a>
                        
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            这个总结写的还算认真，回头看，我真的运气很好，遇到了很多大佬，在我还未毕业时并没有嫌弃我傻，教我的不仅仅是技术，还有理财、为人处世，下面是我这一年的成长经历。
有一段时间因为华为 34 岁以上员工被裁、中兴程序员跳楼等事件的发生，各种蹭热点讨论“中年危机”的文章漫天飞，那时我正忙于找工作。
当时一个微信群里面大家各种讨论中年危机，都在给自己制造焦虑，刚好群里有个大神可能看大家过于焦虑，就在群里发了几条消息，教大家如何避免中年危机，并且推荐了两本书。
还是学生的我下意识的就发了一个添加好友请求，庆幸的是他同意了我的好友请求，当然我们没有什么交流，我的问题过于浅显，我明白自己这个水平问问题，会浪费人家时间，当时的想法是看看大神的朋友圈，他平时都接触什么，自己学习一段时间。
大神推荐的书是李笑来写的《把时间当做朋友》、《财富自由之路》，两本书在学校图书馆都没有，我就给学校图书馆荐购系统提交了这两本书，图书馆效率也挺高，不到一周就把书给买回来了，我立马就借回来阅读。
书中的内容刷新了我以前狭隘的认知，自己从来没有像书中那样考虑问题，除了对作者的佩服之外，更多的是思考自己这种学生思维局限性太大了，要慢慢的将它摒弃。
有个定律是你关心什么就会来什么，后面陆续碰到几位像大神一样的人士，并加了他们的微信，但是都仅仅是通过他们朋友圈的蛛丝马迹去找知识，通过他们朋友圈的分享内容，我知道了“简七理财”、“码农翻身”公众号，然后知道了《富爸爸穷爸爸》、《小狗钱钱》，于是我通过微信读书，读完了这两本书，逐渐培养了理财理念。
后来没隔多久，简七出书了，我第一时间就买了她写的《好好赚钱》（同期还有刘大也出了《码农翻身》一书，我也第一时间买了），简七写的内容通俗易懂，很容易理解。
刘大在群里开了几次公开课，作为计算机专业的我，被刘大对技术的理解之深给折服了，正是业界浮躁的时候，成千上万人想着人工智能、大数据、区块链，而刘大一直能沉下心来去了解技术的原理，这给了我一个很好的榜样，我也逐渐沉下心来，开始去补最基础的知识，像《深入理解计算机系统》一类书也能尽下心来慢慢去啃（当时没啃完，最近又在啃），这种不浮躁的特质对我的技术成长是很有帮助的。
此后有一天，另一个大神在朋友圈分享了曹大写的《从校园到职场系列文章》，喜欢深入挖掘信息的我，以曹大公众号为源头，又找到了冯大、池大、二爷等人的公众号。
作为自由的大四学生，因为不用担心第二天起不来，我那段时间经常熬夜阅读他们的文章，再阅读的过程中我也开始思考自己此前哪些想法狭隘，哪些品质又是值得继续保持的。
也是那时开始接受知识付费的，那时候已经有小密圈（现在叫知识星球）了，出于对几位大佬的信任，我第一次大胆的花了几百块钱加入了刘大、曹大、冯大、程序员小灰的小密圈，其中的内容比网上蹭热点的文章好不知多少倍，一贯爱捕捉蛛丝马迹的我，又通过评论信息发现了 angela zhu、子柳老师、陈利人老师等，然后去找他们的文章，他们输出的内容要比水军写的文章好太多。
自己也是从那时候开始坚持写文章记录自己的心得的，通过写文章，我认识了很多优秀的人，比如吴小龙同学、了不起的杰克、java 小咖秀等公众号的作者，和他们交流的很少，但是却很受用，他们的积极向上也影响着我一直保持着乐观豁达的心态。
自己写的文章也被几个资深程序员赞同，同时还收到了两个出版社发来的出书邀请，让我体会到了无心插柳柳成荫的收获。
让我坚持一直写文章的动力不是赚钱，而是我切切实实体会到了它给我个人带来的成长，为了自己日后再看时能立刻就找到清晰的逻辑，我把都尽可能把文章写得有理有据，掌握自己的节奏，尽量提高文章质量。此前写的谈一下写作的重要性一文有说写作可以带来的好处。
现在已经不把自己当新人了，而且有同龄人甚至比我年龄还大的人向我咨询问题时，我也能给出合理建议，都得到了他们的肯定。最近发现和周围伙伴最明显的一个区别就是，对于同一个新闻，我经常早于他们半天甚至一两天知道，而且掌握的信息比他们还准确，我认为这就是整体认知水平的提升。
想说的是，执行力与信息素养很重要，执行力强的人会与你拉开越来越大的距离，信息素养也是一个关键品质，现在网络上充斥着大量的虚假信息，如何去分别这些信息的真假，在相同条件下如何获得更多的有效信息，是必备的能力。
当前年龄 23，刚大学毕业几个月，没读研。按十年为期给自己定了几个小小的目标：
父母是地地道道的农民，智能手机都不会用，十年之类给自己和父母把重疾险、意外险之类的保险配置齐全，虽然父辈一直反对买保险。
提高获取信息的能力，虽然现在对信息的掌握都比周边伙伴要早半天至几天，但是都不是自己的分析结果，学习以时间的纬度跟踪事件的发展。
学习理财知识，现在只对信用卡、基金有一点点的了解，不管炒不炒股，金融知识都还是要学的，这方面通过看书、阅读、小额实操学习。
提升自己的技术实力，职业是程序员，前后端都做，但是自己对技术的热情不是多么高涨（至少比身边一半人要高涨），以我对自己的了解，我在技术的道路上成长为小公司一个的架构师应该不成问题，再高层级怕是不行。
慢慢做到不止一份收入来源，这方面不是多清晰，现在每个月平均会有 200 左右的非工资收入（帮助别人时发的红包等），十年后做到其它收入基本和工资持平。不至于因为钱的问题而忍受心中的不快，至少得有能指着老板的鼻子说“老子不干了”的底气。
世界那么大，应该去看看，国内除了西北地区，中国很多地方已经留下了我的足迹，旅游不仅仅是玩耍，更是提升见识、获得灵感的有效途径，十年至少得把自己的脚印印到 5 个国家的土地上吧。
十年之后应该已经结婚了，房子是现在最遥不可及的目标，但是心里莫名有一股自信，这个后面会实现的，虽然不知道哪里来的这股自信。
最后一个，趁年轻，多学习，做一个终身学习的人，时刻保持学习的态度，多做有利于他人的事，现在水平不高，我能帮助到的大部分都是硕士及以下。努力提高自己，帮助更多的人。更大的目标是能给山区学校带去一些更好的教育资源。

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://www.guanngxu.com/s1Mfu1JcV/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
    <div class="pagination-container">
        
            <a href="https://www.guanngxu.com/page/6/" class="page-btn btn">上一页</a>
            
                
                    <a href="https://www.guanngxu.com/page/8/" class="page-btn btn">下一页</a>
                    
    </div>
    

                <!-- 金山词霸 -->
                <!-- <script>
                    const date = new Date();
                    const today = date.toISOString().substring(0, 10);
                    console.info(today)
                    $.ajax({
                        url: `http://sentence.iciba.com/index.php?c=dailysentence&m=getdetail&title=${today}`,
                        type: "GET",
                        dataType: "jsonp", //指定服务器返回的数据类型
                        success: function (data) {
                            $(".null-feature-image").css("background-image", `url(${data.picture2})`);
                            console.log(data);
                        }
                    });
                </script> -->
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar">
            <img src="https://www.guanngxu.com/images/avatar.png?v=1751462361215">
        </div>
        <h1 class="id_card-title">
            Guanngxu
        </h1>
        <h2 class="id_card-description">
            Keep trying
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                <a href="https://github.com/Guanngxu" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-github"></i></a>
                
                    <!-- twitter -->
                    
                        <a href="https://twitter.com/guanngxu" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-twitter"></i></a>
                        
                            <!-- weibo -->
                            
                                <a href="https://weibo.com/u/5288280194" target="_blank" rel="noopener noreferrer"><i
                class="fa fa-weibo"></i></a>
                                
                                    <!-- facebook -->
                                    
                                        <!-- douban -->
                                        
                                            <a href="https://www.douban.com/people/Guanngxu" target="_blank" rel="noopener noreferrer">
                                                <svg t="1660751300927" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2563" width="200" height="200"><path d="M1023.979 862.827A161.152 161.152 0 0 1 862.805 1024H161.173A161.152 161.152 0 0 1 0 862.827V161.195A161.195 161.195 0 0 1 161.173 0.02h701.632a161.195 161.195 0 0 1 161.174 161.174v701.632z" fill="#515151" p-id="2564" data-spm-anchor-id="a313x.7781069.0.i2" class="selected"></path><path d="M218.56 208.064h586.816v66.09H218.56z m535.83 393.493v-258.41h-484.8v258.41h484.8zM339.882 409.173H684.8v126.358H339.883V409.173z m309.61 341.334c21.099-32.299 41.003-69.739 59.435-112.256l-70.507-25.707c-18.346 50.368-39.701 96.427-64 137.941H451.712c-20.373-53.802-43.328-99.818-69.077-137.941l-64.854 25.707c26.752 40.128 48.32 77.482 64.854 112.256H201.94v65.386h620.054v-65.386H649.493z" fill="#FFFFFF" p-id="2565" data-spm-anchor-id="a313x.7781069.0.i3" class=""></path></svg>
                                            </a>
                                        

        </div>
    </div>
    
    <script>
        // const date = new Date();
        // const today = date.toISOString().substring(0, 10);
        // console.info(today)
        // $.ajax({
        //     url: `http://sentence.iciba.com/index.php?c=dailysentence&m=getdetail&title=${today}`,
        //     type: "GET",
        //     dataType: "jsonp", //指定服务器返回的数据类型
        //     success: function (data) {
        //         $(".id_card-description").text(data.content)
        //         console.log(data);
        //     }
        // });
    </script>
                        <!-- 最新文章 -->
                        <div class="new_posts_card i-card">
    <h2 class="new_posts_card-title">
        最新文章
    </h2>
    <div class="new-posts">
        
        
            <h4>
                <a href="https://www.guanngxu.com/yWl6bPr5jd/">动态电压调节</a>
            </h4>
        
        
        
            <h4>
                <a href="https://www.guanngxu.com/VvjVruOGrV/">Boost 电路基础知识</a>
            </h4>
        
        
        
            <h4>
                <a href="https://www.guanngxu.com/-loFmea4T/">电源 PCB 布局及其常见错误</a>
            </h4>
        
        
        
            <h4>
                <a href="https://www.guanngxu.com/asBsvJSki/">电平转换器基础知识</a>
            </h4>
        
        
        
            <h4>
                <a href="https://www.guanngxu.com/L3EbniCYD/">LDO 基础知识</a>
            </h4>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    </div>
</div>
                            <!-- 标签云 -->
                            <div class="tags_card i-card">
    <h2 class="tags_card-title">
        标签云
    </h2>
    <div class="tags-card-container">
        
        <a class="tags-tag i-tag
            i-tag-other_2" href="https://www.guanngxu.com/HoPoXlgLN/">
            线性稳压器
        </a>
        
        <a class="tags-tag i-tag
            i-tag-banana" href="https://www.guanngxu.com/jSM-A51qWd/">
            LDO
        </a>
        
        <a class="tags-tag i-tag
            i-tag-" href="https://www.guanngxu.com/QbHW4oh0b/">
            开关电源
        </a>
        
        <a class="tags-tag i-tag
            i-tag-success" href="https://www.guanngxu.com/g-HWNOeTH/">
            BUCK
        </a>
        
        <a class="tags-tag i-tag
            i-tag-other_1" href="https://www.guanngxu.com/f2t0BU6fkn/">
            DC-DC
        </a>
        
        <a class="tags-tag i-tag
            i-tag-other_1" href="https://www.guanngxu.com/pCdNazHt7/">
            电路基础
        </a>
        
        <a class="tags-tag i-tag
            i-tag-other_1" href="https://www.guanngxu.com/COeYlWWen/">
            PCB
        </a>
        
        <a class="tags-tag i-tag
            i-tag-error" href="https://www.guanngxu.com/ypjmBXLlm3/">
            Layout
        </a>
        
        <a class="tags-tag i-tag
            i-tag-other_1" href="https://www.guanngxu.com/ONdBQtmOe/">
            电平转换
        </a>
        
        <a class="tags-tag i-tag
            i-tag-" href="https://www.guanngxu.com/krqSF7tYC/">
            算法
        </a>
        
        <a class="tags-tag i-tag
            i-tag-other_3" href="https://www.guanngxu.com/umBdDP7Ll/">
            C
        </a>
        
        <a class="tags-tag i-tag
            i-tag-other_3" href="https://www.guanngxu.com/M4PlaWNdk/">
            Oracle
        </a>
        
        <a class="tags-tag i-tag
            i-tag-primary" href="https://www.guanngxu.com/ecG5hxBcr/">
            数据库
        </a>
        
        <a class="tags-tag i-tag
            i-tag-success" href="https://www.guanngxu.com/hF3_PWTirK/">
            Java
        </a>
        
        <a class="tags-tag i-tag
            i-tag-primary" href="https://www.guanngxu.com/vnEfA3xxL/">
            嵌入式
        </a>
        
        <a class="tags-tag i-tag
            i-tag-error" href="https://www.guanngxu.com/mZ_iBKmVWo/">
            操作系统
        </a>
        
        <a class="tags-tag i-tag
            i-tag-other_3" href="https://www.guanngxu.com/Ykw3uqJED/">
            随笔思考
        </a>
        
        <a class="tags-tag i-tag
            i-tag-error" href="https://www.guanngxu.com/wgJXq4UXE/">
            Git
        </a>
        
        <a class="tags-tag i-tag
            i-tag-info" href="https://www.guanngxu.com/BDX4-XwWJ/">
            信用卡
        </a>
        
        <a class="tags-tag i-tag
            i-tag-other_1" href="https://www.guanngxu.com/ML7-KNp5c/">
            赚钱套利
        </a>
        
        <a class="tags-tag i-tag
            i-tag-success" href="https://www.guanngxu.com/3pFNTYNB8/">
            翻译摘录
        </a>
        
        <a class="tags-tag i-tag
            i-tag-warning" href="https://www.guanngxu.com/ndHrBQqET/">
            社会经验
        </a>
        
        <a class="tags-tag i-tag
            i-tag-error" href="https://www.guanngxu.com/mVmVUsbMe/">
            工具教程
        </a>
        
        <a class="tags-tag i-tag
            i-tag-primary" href="https://www.guanngxu.com/6ZjSGnvm9/">
            年度总结
        </a>
        
        <a class="tags-tag i-tag
            i-tag-primary" href="https://www.guanngxu.com/u3bra3rlo/">
            健康生活
        </a>
        
        <a class="tags-tag i-tag
            i-tag-info" href="https://www.guanngxu.com/QNwNfWJcwj/">
            灰产骗局
        </a>
        
        <a class="tags-tag i-tag
            i-tag-info" href="https://www.guanngxu.com/wjM4wf9IE/">
            MySQL
        </a>
        
        <a class="tags-tag i-tag
            i-tag-warning" href="https://www.guanngxu.com/dTizl9yei/">
            SEO
        </a>
        
        <a class="tags-tag i-tag
            i-tag-banana" href="https://www.guanngxu.com/7QbLXmeen/">
            Vue
        </a>
        
        <a class="tags-tag i-tag
            i-tag-other_2" href="https://www.guanngxu.com/6ys69eBdL/">
            前端
        </a>
        
        <a class="tags-tag i-tag
            i-tag-banana" href="https://www.guanngxu.com/EWmAbJCJGF/">
            TypeScript
        </a>
        
        <a class="tags-tag i-tag
            i-tag-" href="https://www.guanngxu.com/ovndYzDa7N/">
            JavaScript
        </a>
        
        <a class="tags-tag i-tag
            i-tag-other_1" href="https://www.guanngxu.com/iqW8DWbw7/">
            MongoDB
        </a>
        
        <a class="tags-tag i-tag
            i-tag-" href="https://www.guanngxu.com/XcHzo7Nc6/">
            正则表达式
        </a>
        
        <a class="tags-tag i-tag
            i-tag-warning" href="https://www.guanngxu.com/UGoTtZqQ-y/">
            编译原理
        </a>
        
        <a class="tags-tag i-tag
            i-tag-primary" href="https://www.guanngxu.com/j7DVou3EA/">
            Nginx
        </a>
        
        <a class="tags-tag i-tag
            i-tag-banana" href="https://www.guanngxu.com/sQhfLtj4g/">
            计算机网络
        </a>
        
        <a class="tags-tag i-tag
            i-tag-warning" href="https://www.guanngxu.com/KCICs8Iip/">
            记录回忆
        </a>
        
        <a class="tags-tag i-tag
            i-tag-primary" href="https://www.guanngxu.com/9WeHlVlqK9/">
            软件测试
        </a>
        
        <a class="tags-tag i-tag
            i-tag-info" href="https://www.guanngxu.com/EEBe6eBp1/">
            爬虫
        </a>
        
        <a class="tags-tag i-tag
            i-tag-info" href="https://www.guanngxu.com/_7KBEW1cq7/">
            Python
        </a>
        
        <a class="tags-tag i-tag
            i-tag-other_3" href="https://www.guanngxu.com/pkJGoZIqgD/">
            Angular
        </a>
        
        <a class="tags-tag i-tag
            i-tag-" href="https://www.guanngxu.com/_9zQ4w6VQ/">
            自然语言处理
        </a>
        
    </div>
</div>
                                <!-- 公告栏 -->
                                

                </div>
            </div>



            <div class="site-footer">
  <a href="https://beian.miit.gov.cn" target="_blank">蜀ICP备2022021904号</a> | 
  <a class="rss" href="https://www.guanngxu.com/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>